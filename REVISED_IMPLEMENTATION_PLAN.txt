==============================================================================
NFC 병원 안내 시스템 - 수정된 구현 계획서 (병렬 처리 및 점진적 개선)
==============================================================================
작성일: 2025-09-06
버전: 2.0.0
프로젝트: NFC Hospital Guide System

==============================================================================
📌 핵심 개선 사항
==============================================================================

1. 병렬 작업 구조 도입
   - 3개 팀이 동시 진행으로 개발 기간 40% 단축
   - Mock API 활용으로 의존성 제거

2. 점진적 모델 개선
   - Baseline → LSTM 단계적 전환
   - 빠른 배포, 지속적 개선

3. 설정 기반 자동화
   - YAML 설정 파일로 데이터 생성 관리
   - 재사용 가능한 테스트 환경

4. 현실적 버퍼 확보
   - 12일 → 10일 개발 + 5일 버퍼
   - 리스크 대응 여유 확보

==============================================================================
🚀 병렬 개발 트랙 구조
==============================================================================

┌──────────────┬──────────────┬──────────────┐
│   Track A    │   Track B    │   Track C    │
│  (Backend)   │  (Frontend)  │    (Data)    │
├──────────────┼──────────────┼──────────────┤
│ EMR Data     │ UI Redesign  │ Navigation   │
│ Analytics    │ Mock API     │ Test Data    │
│ Baseline ML  │ Dashboard    │ Monitoring   │
│ LSTM Model   │ Integration  │ Performance  │
└──────────────┴──────────────┴──────────────┘

==============================================================================
📅 수정된 일정표 (10일 개발 + 5일 버퍼)
==============================================================================

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
WEEK 1: Sprint 1 (Day 1-5) - 기반 구축
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

┌─────────────────────────────────────────────────────────────────────────┐
│ Day 1-2: 데이터 및 UI 기반                                              │
└─────────────────────────────────────────────────────────────────────────┘

[Track A - Backend]
작업 A1: EMR 데이터 생성 자동화
├─ 파일: generate_emr_data.py
├─ 설정: emr_config.yaml
└─ 내용:
   ```yaml
   # emr_config.yaml
   emr_data:
     patients: 100
     days: 30
     departments:
       radiology:
         peak_hours: [9, 10, 11]
         avg_wait_time: 35
         patient_flow_pattern: "morning_peak"
       laboratory:
         peak_hours: [13, 14, 15]
         avg_wait_time: 25
         patient_flow_pattern: "afternoon_peak"
   ```

[Track B - Frontend]
작업 B1: 환자 진행바 UI 개선
├─ 파일: ProgressBar.jsx
├─ 요구사항:
│  ├─ 폰트 크기: 20px 이상
│  ├─ 터치 영역: 56px 이상
│  └─ 애니메이션: framer-motion 사용
└─ 병렬 가능: BE API 독립적

[Track C - Data/Infra]
작업 C1: Navigation 노드 자동 생성
├─ 파일: create_navigation_nodes.py
├─ 설정: navigation_config.yaml
└─ 내용:
   ```yaml
   # navigation_config.yaml
   navigation:
     buildings:
       main:
         floors: [1, 2]
         nodes_per_floor: 20
         node_types: ["entrance", "elevator", "stairs", "room", "hallway"]
       cancer_center:
         floors: [1, 2]
         nodes_per_floor: 15
     auto_connect:
       max_distance: 50  # meters
       connection_types: ["hallway", "elevator", "stairs"]
   ```

┌─────────────────────────────────────────────────────────────────────────┐
│ Day 3-4: API 및 Mock 시스템                                             │
└─────────────────────────────────────────────────────────────────────────┘

[Track A - Backend]
작업 A2: Analytics API 구현
├─ 엔드포인트:
│  ├─ GET /api/v1/analytics/realtime-stats
│  ├─ GET /api/v1/analytics/department-status
│  └─ WS /ws/dashboard/
└─ 응답 형식 확정 (Contract First)

작업 A3: Celery 실시간 업데이트
├─ 60초마다 EMR 상태 업데이트
└─ WebSocket 브로드캐스트

[Track B - Frontend]
작업 B2: Mock API 서버 구축
├─ 파일: mockServer.js
├─ 도구: json-server 또는 MSW
└─ 내용:
   ```javascript
   // mockServer.js
   const mockData = {
     '/api/v1/analytics/realtime-stats': {
       departments: [
         {
           id: 'radiology',
           waitingPatients: 15,
           avgWaitTime: 35,
           status: 'busy'
         }
       ]
     }
   };
   ```

작업 B3: Dashboard Service 구현
├─ 파일: dashboardService.js
├─ Mock/Real API 전환 가능
└─ Feature Flag 사용

[Track C - Data/Infra]
작업 C2: 테스트 데이터 파이프라인
├─ Docker Compose 설정
├─ 테스트 DB 격리
└─ CI/CD 통합

┌─────────────────────────────────────────────────────────────────────────┐
│ Day 5: Baseline 모델 및 초기 통합                                        │
└─────────────────────────────────────────────────────────────────────────┘

[Track A - Backend]
작업 A4: Baseline 예측 모델
├─ 방법: 이동평균 (Moving Average)
├─ 파일: baseline_predictor.py
└─ 내용:
   ```python
   class BaselinePredictor:
       def predict(self, department, timeframe):
           # 최근 7일 같은 시간대 평균
           historical_data = self.get_historical_data(
               department, 
               timeframe
           )
           return {
               "prediction": np.mean(historical_data),
               "confidence": 0.75,
               "method": "moving_average"
           }
   ```

[Track B - Frontend]
작업 B4: 대시보드 컴포넌트 연결
├─ OperationalMonitor.jsx → Mock API
├─ LSTMPrediction.jsx → Baseline API
└─ 실시간 업데이트 테스트

[Track C - Data/Infra]
작업 C3: 모니터링 시스템 구축
├─ Prometheus 메트릭 수집
├─ Grafana 대시보드
└─ 알림 설정

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
WEEK 2: Sprint 2 (Day 6-10) - 고도화 및 통합
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

┌─────────────────────────────────────────────────────────────────────────┐
│ Day 6-8: LSTM 모델 및 실제 통합                                          │
└─────────────────────────────────────────────────────────────────────────┘

[Track A - Backend]
작업 A5: LSTM 모델 개발
├─ 파일: lstm_predictor.py
├─ 구조:
│  ```python
│  class LSTMPredictor:
│      def __init__(self):
│          self.model = self._build_model()
│          self.scaler = MinMaxScaler()
│      
│      def _build_model(self):
│          model = Sequential([
│              LSTM(64, return_sequences=True, input_shape=(24, 5)),
│              Dropout(0.2),
│              LSTM(32, return_sequences=False),
│              Dense(16, activation='relu'),
│              Dense(1)
│          ])
│          model.compile(optimizer='adam', loss='mse')
│          return model
│      
│      def train(self, X, y):
│          # 오프라인 학습 (백그라운드)
│          self.model.fit(X, y, epochs=50, batch_size=32)
│  ```
└─ A/B 테스트 준비

[Track B - Frontend]
작업 B5: 실제 API 통합
├─ Mock → Real API 전환
├─ WebSocket 연결
└─ 에러 핸들링 강화

작업 B6: 지도 경로 시각화
├─ 파일: PathRenderer.jsx
├─ SVG 경로 애니메이션
└─ 실시간 위치 업데이트

[Track C - Data/Infra]
작업 C4: 성능 최적화
├─ Redis 캐싱 설정
├─ DB 인덱스 최적화
└─ CDN 설정

┌─────────────────────────────────────────────────────────────────────────┐
│ Day 9-10: 통합 테스트 및 안정화                                          │
└─────────────────────────────────────────────────────────────────────────┘

[모든 트랙 통합]
작업 통합1: End-to-End 테스트
├─ 시나리오 테스트
├─ 부하 테스트
└─ 사용성 테스트

작업 통합2: 버그 수정
├─ 우선순위별 처리
└─ 핫픽스 적용

작업 통합3: 문서화
├─ API 문서 업데이트
├─ 사용자 가이드
└─ 운영 매뉴얼

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
WEEK 3: 버퍼 및 최적화 (Day 11-15)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Day 11-12: LSTM 고도화
├─ 하이퍼파라미터 튜닝
├─ 추가 학습 데이터 수집
└─ 모델 앙상블 테스트

Day 13-14: 성능 및 안정성
├─ 메모리 누수 점검
├─ 응답 시간 최적화
└─ 장애 복구 테스트

Day 15: 최종 검증
├─ 고령자 사용성 테스트
├─ 의료진 피드백 수집
└─ 배포 준비

==============================================================================
🔧 기술적 구현 상세
==============================================================================

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Feature Flag 시스템
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

```javascript
// frontend-pwa/src/config/features.js
const features = {
  // API 설정
  useMockAPI: process.env.REACT_APP_USE_MOCK === 'true',
  apiBaseUrl: features.useMockAPI 
    ? 'http://localhost:3001' 
    : process.env.REACT_APP_API_URL,
  
  // 모델 설정
  predictionModel: process.env.REACT_APP_PREDICTION_MODEL || 'baseline',
  
  // UI 기능
  enableAnimations: process.env.REACT_APP_ANIMATIONS !== 'false',
  elderlyMode: process.env.REACT_APP_ELDERLY_MODE === 'true',
  
  // 실험적 기능
  enableLSTM: process.env.REACT_APP_ENABLE_LSTM === 'true',
  enableWebSocket: process.env.REACT_APP_ENABLE_WS === 'true'
};

// 사용 예시
const DashboardService = {
  async getPrediction(department, timeframe) {
    const endpoint = features.predictionModel === 'lstm'
      ? '/api/v1/analytics/lstm-predict'
      : '/api/v1/analytics/baseline-predict';
    
    const baseUrl = features.apiBaseUrl;
    return fetch(`${baseUrl}${endpoint}`, {
      method: 'POST',
      body: JSON.stringify({ department, timeframe })
    });
  }
};
```

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Mock Server 구현
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

```javascript
// frontend-pwa/mock/server.js
const express = require('express');
const cors = require('cors');
const app = express();

app.use(cors());
app.use(express.json());

// 실시간 통계 Mock
app.get('/api/v1/analytics/realtime-stats', (req, res) => {
  res.json({
    success: true,
    data: {
      departments: generateDepartmentData(),
      systemHealth: {
        uptime: 99.9,
        responseTime: Math.floor(Math.random() * 50) + 50,
        activeUsers: Math.floor(Math.random() * 50) + 100
      },
      timestamp: new Date().toISOString()
    }
  });
});

// 예측 Mock
app.post('/api/v1/analytics/baseline-predict', (req, res) => {
  const { department, timeframe } = req.body;
  const baseWait = { radiology: 35, laboratory: 25, internal: 30 }[department] || 20;
  
  res.json({
    success: true,
    data: {
      prediction: baseWait + Math.random() * 10,
      confidence: 0.75,
      method: 'moving_average',
      factors: {
        currentLoad: 'medium',
        trend: 'stable'
      }
    }
  });
});

// WebSocket Mock
const WebSocket = require('ws');
const wss = new WebSocket.Server({ port: 8080 });

wss.on('connection', (ws) => {
  const interval = setInterval(() => {
    ws.send(JSON.stringify({
      type: 'department_update',
      data: generateDepartmentData()
    }));
  }, 5000);
  
  ws.on('close', () => clearInterval(interval));
});

app.listen(3001, () => {
  console.log('Mock server running on http://localhost:3001');
});
```

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
설정 기반 데이터 생성
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

```python
# backend/nfc_hospital_system/management/commands/generate_data_from_config.py
import yaml
from django.core.management.base import BaseCommand
from appointments.models import Appointment, Exam
from p_queue.models import Queue
from datetime import datetime, timedelta
import random

class Command(BaseCommand):
    help = 'Generate test data from YAML configuration'
    
    def add_arguments(self, parser):
        parser.add_argument(
            '--config',
            type=str,
            default='config/data_generation.yaml',
            help='Path to YAML configuration file'
        )
    
    def handle(self, *args, **options):
        # YAML 설정 로드
        with open(options['config'], 'r') as f:
            config = yaml.safe_load(f)
        
        # EMR 데이터 생성
        emr_config = config['emr_data']
        self.generate_emr_data(emr_config)
        
        # Navigation 데이터 생성
        nav_config = config['navigation']
        self.generate_navigation_data(nav_config)
        
        self.stdout.write(self.style.SUCCESS('Data generation completed'))
    
    def generate_emr_data(self, config):
        """EMR 데이터 생성"""
        num_patients = config['patients']
        num_days = config['days']
        
        for dept_id, dept_config in config['departments'].items():
            for day in range(num_days):
                date = datetime.now() - timedelta(days=num_days-day)
                
                # 시간대별 패턴 적용
                for hour in dept_config['peak_hours']:
                    num_appointments = random.randint(5, 15)
                    
                    for _ in range(num_appointments):
                        # Appointment 생성
                        appointment = Appointment.objects.create(
                            scheduled_at=date.replace(hour=hour),
                            exam_id=f"exam_{dept_id}",
                            # ... 기타 필드
                        )
                        
                        # Queue 생성
                        Queue.objects.create(
                            appointment=appointment,
                            estimated_wait_time=random.gauss(
                                dept_config['avg_wait_time'],
                                5
                            ),
                            state='waiting'
                        )
    
    def generate_navigation_data(self, config):
        """Navigation 노드 및 엣지 생성"""
        from hospital_navigation.models import NavigationNode, NavigationEdge
        
        for building_name, building_config in config['buildings'].items():
            for floor in building_config['floors']:
                nodes_per_floor = building_config['nodes_per_floor']
                
                # 노드 생성
                nodes = []
                for i in range(nodes_per_floor):
                    node = NavigationNode.objects.create(
                        name=f"{building_name}_F{floor}_N{i}",
                        building=building_name,
                        floor=floor,
                        x_coord=random.uniform(0, 100),
                        y_coord=random.uniform(0, 100)
                    )
                    nodes.append(node)
                
                # 자동 연결 (인접 노드)
                if config.get('auto_connect'):
                    max_distance = config['auto_connect']['max_distance']
                    for i, node1 in enumerate(nodes):
                        for node2 in nodes[i+1:]:
                            distance = self.calculate_distance(node1, node2)
                            if distance <= max_distance:
                                NavigationEdge.objects.create(
                                    from_node=node1,
                                    to_node=node2,
                                    distance=distance,
                                    edge_type='hallway',
                                    is_bidirectional=True
                                )
```

==============================================================================
📊 성공 지표 (개정판)
==============================================================================

Sprint 1 (Day 1-5) - 기반 구축
--------------------------------
□ Mock API 100% 구현 완료
□ UI 고령자 친화 디자인 적용
□ 테스트 데이터 10,000+ 레코드 생성
□ Feature Flag 시스템 구축
□ 병렬 작업 트랙 확립

Sprint 2 (Day 6-10) - 고도화
--------------------------------
□ 실제 API 연결 완료
□ Baseline 예측 정확도 75%+
□ WebSocket 실시간 통신 구현
□ 경로 자동 계산 성공률 95%+
□ 통합 테스트 커버리지 80%+

Sprint 3 (Day 11-15) - 최적화
--------------------------------
□ LSTM 예측 정확도 90%+ (30분 이내)
□ API 응답 시간 < 200ms (P95)
□ 시스템 가용성 99.9%+
□ 고령자 사용성 점수 4.5/5.0+
□ 프로덕션 배포 준비 완료

==============================================================================
🚨 리스크 관리 매트릭스
==============================================================================

┌─────────────────────┬──────────┬──────────┬─────────────────────────────┐
│ 리스크              │ 가능성   │ 영향도   │ 대응 방안                   │
├─────────────────────┼──────────┼──────────┼─────────────────────────────┤
│ API 통합 지연       │ 낮음     │ 높음     │ Mock API로 계속 개발        │
│ LSTM 정확도 미달    │ 중간     │ 중간     │ Baseline 모델 유지          │
│ 데이터 불일치       │ 낮음     │ 높음     │ 설정 파일 버전 관리         │
│ 성능 이슈           │ 중간     │ 중간     │ 캐싱 및 CDN 적극 활용      │
│ 병렬 작업 충돌      │ 낮음     │ 낮음     │ Git 브랜치 전략 엄격 적용  │
└─────────────────────┴──────────┴──────────┴─────────────────────────────┘

==============================================================================
💡 핵심 성공 요인
==============================================================================

1. Mock 우선 개발
   - 의존성 제거로 병렬 작업 가능
   - API 계약 먼저 정의

2. 점진적 개선
   - Baseline → LSTM 단계적 전환
   - 빠른 배포, 지속적 개선

3. 자동화 극대화
   - 설정 기반 데이터 생성
   - CI/CD 파이프라인 구축

4. 충분한 버퍼
   - 50% 버퍼 기간 확보
   - 예상치 못한 이슈 대응 가능

==============================================================================
📝 체크리스트
==============================================================================

개발 환경 준비
□ Docker Compose 설정
□ Mock Server 구동
□ Feature Flag 설정
□ YAML 설정 파일 준비

팀 구성
□ Backend 개발자 2명
□ Frontend 개발자 2명
□ Data/DevOps 1명

도구 및 서비스
□ GitHub Actions CI/CD
□ Prometheus + Grafana
□ Redis Cache
□ Celery + Redis Queue

문서화
□ API 명세서 (OpenAPI)
□ 컴포넌트 스토리북
□ 운영 가이드
□ 트러블슈팅 가이드

==============================================================================
마무리
==============================================================================

이 수정된 계획은 다음과 같은 장점을 제공합니다:

✅ 병렬 작업으로 개발 속도 40% 향상
✅ Mock API로 의존성 없는 개발
✅ 점진적 모델 개선으로 리스크 감소
✅ 설정 기반 자동화로 재사용성 증대
✅ 충분한 버퍼로 안정적인 일정 관리

성공적인 프로젝트 완수를 위해 팀원 간 긴밀한 소통과
일일 스탠드업 미팅을 권장합니다.

==============================================================================
문서 정보
==============================================================================
버전: 2.0.0
작성일: 2025-09-06
작성자: Claude Code
검토자: [검토 예정]
승인자: [승인 예정]
==============================================================================