================================================================================
ê¸°ëŠ¥ë³„ ìƒì„¸ ë¶„ì„ ë³´ê³ ì„œ #6: ì§€ë„ ë° ê²½ë¡œ ì•ˆë‚´ ì‹œìŠ¤í…œ
================================================================================
ì‘ì„±ì¼: 2025ë…„ 1ì›” 9ì¼
ë¶„ì„ ë²”ìœ„: ë°±ì—”ë“œ + í”„ë¡ íŠ¸ì—”ë“œ í†µí•©
í˜„ì¬ ì™„ì„±ë„: 70%
================================================================================

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ ê´€ë ¨ íŒŒì¼ êµ¬ì¡°
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ã€ë°±ì—”ë“œã€‘
backend/nfc_hospital_system/hospital_navigation/
â”œâ”€â”€ models.py                   # NavigationNode, NavigationEdge, HospitalMap
â”œâ”€â”€ pathfinding.py              # A* ì•Œê³ ë¦¬ì¦˜ ê²½ë¡œ íƒìƒ‰
â”œâ”€â”€ views.py                    # ê²½ë¡œ ê³„ì‚° API
â”œâ”€â”€ serializers.py              # ê²½ë¡œ ë°ì´í„° ì‹œë¦¬ì–¼ë¼ì´ì €
â””â”€â”€ management/commands/
    â”œâ”€â”€ load_maps_to_db.py      # SVG ì§€ë„ ë°ì´í„° ë¡œë“œ
    â””â”€â”€ seed_navigation_data.py # ë„¤ë¹„ê²Œì´ì…˜ ë°ì´í„° ì‹œë“œ

backend/nfc_hospital_system/nfc/
â”œâ”€â”€ models/facility_route.py   # FacilityRoute ëª¨ë¸
â””â”€â”€ views/facility_routes.py   # ì‹œì„¤ ê²½ë¡œ API

ã€í”„ë¡ íŠ¸ì—”ë“œã€‘
frontend-pwa/
â”œâ”€â”€ src/components/maps/
â”‚   â”œâ”€â”€ InteractiveMapViewer.jsx  # SVG ì§€ë„ ë·°ì–´
â”‚   â”œâ”€â”€ MapViewer.jsx             # ê¸°ë³¸ ì§€ë„ í‘œì‹œ
â”‚   â”œâ”€â”€ MapNavigator.jsx          # ê²½ë¡œ ì•ˆë‚´ ë„¤ë¹„ê²Œì´í„°
â”‚   â”œâ”€â”€ SimpleMapViewer.jsx      # ê°„ë‹¨í•œ ì§€ë„ ë·°ì–´
â”‚   â””â”€â”€ MapLegend.jsx            # ì§€ë„ ë²”ë¡€
â”œâ”€â”€ src/data/
â”‚   â”œâ”€â”€ mapConfig.js            # ì§€ë„ ì„¤ì •
â”‚   â””â”€â”€ facilityRoutes.js       # ì‹œì„¤ ê²½ë¡œ ë°ì´í„°
â””â”€â”€ public/images/maps/         # SVG ì§€ë„ íŒŒì¼ (14ê°œ)
    â”œâ”€â”€ main_1f.svg
    â”œâ”€â”€ main_2f.svg
    â”œâ”€â”€ cancer_1f.svg
    â””â”€â”€ ...

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ” í˜„ì¬ êµ¬í˜„ ìƒíƒœ ë¶„ì„
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

================================================================================
1. ë°±ì—”ë“œ ê²½ë¡œ ì‹œìŠ¤í…œ
================================================================================

ã€âœ… ì˜ êµ¬í˜„ëœ ë¶€ë¶„ã€‘

1.1 ê·¸ë˜í”„ ê¸°ë°˜ ë„¤ë¹„ê²Œì´ì…˜ ëª¨ë¸
```python
class NavigationNode(models.Model):
    node_id = models.UUIDField(primary_key=True, default=uuid.uuid4)
    building = models.CharField(max_length=100)
    floor = models.IntegerField()
    x_coord = models.FloatField()
    y_coord = models.FloatField()
    z_coord = models.FloatField(default=0)
    node_type = models.CharField(max_length=20)  # room, hallway, elevator, stairs
    is_accessible = models.BooleanField(default=True)
    nfc_tag = models.OneToOneField('nfc.NFCTag', null=True)

class NavigationEdge(models.Model):
    from_node = models.ForeignKey(NavigationNode, related_name='outgoing_edges')
    to_node = models.ForeignKey(NavigationNode, related_name='incoming_edges')
    distance = models.FloatField()  # ë¯¸í„°
    walk_time = models.FloatField()  # ì´ˆ
    is_accessible = models.BooleanField(default=True)
    avg_congestion = models.FloatField(default=0.5)  # 0-1 í˜¼ì¡ë„
```
- ì™„ì „í•œ ê·¸ë˜í”„ ë°ì´í„° êµ¬ì¡° âœ“
- ì ‘ê·¼ì„± ì •ë³´ í¬í•¨ âœ“
- í˜¼ì¡ë„ ë°˜ì˜ ê°€ëŠ¥ âœ“
- NFC íƒœê·¸ ì—°ê²° âœ“

1.2 A* ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„
```python
class AStarPathfinder:
    def find_path(self, start_node, end_node, avoid_stairs=False):
        open_set = [(0, start_node)]
        g_score = {start_node: 0}
        f_score = {start_node: self.heuristic(start_node, end_node)}
        came_from = {}
        
        while open_set:
            current = heapq.heappop(open_set)[1]
            
            if current == end_node:
                return self.reconstruct_path(came_from, current)
            
            for edge in current.outgoing_edges.all():
                if avoid_stairs and edge.edge_type == 'stairs':
                    continue
                    
                tentative_g = g_score[current] + edge.walk_time
                
                if tentative_g < g_score.get(edge.to_node, float('inf')):
                    came_from[edge.to_node] = current
                    g_score[edge.to_node] = tentative_g
                    f_score[edge.to_node] = tentative_g + self.heuristic(edge.to_node, end_node)
                    heapq.heappush(open_set, (f_score[edge.to_node], edge.to_node))
```
- í‘œì¤€ A* ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„ âœ“
- ì œì•½ ì¡°ê±´ ì§€ì› (avoid_stairs) âœ“
- íœ´ë¦¬ìŠ¤í‹± í•¨ìˆ˜ ì‚¬ìš© âœ“

1.3 ê²½ë¡œ ì•ˆë‚´ ë‹¨ê³„ ìƒì„±
```python
def generate_navigation_steps(path):
    steps = []
    for i in range(len(path) - 1):
        current = path[i]
        next_node = path[i + 1]
        
        direction = calculate_direction(current, next_node)
        distance = calculate_distance(current, next_node)
        
        steps.append({
            'instruction': f"{direction}ìœ¼ë¡œ {distance}m ì´ë™",
            'node': next_node,
            'floor_change': current.floor != next_node.floor
        })
    return steps
```
- ì‚¬ìš©ì ì¹œí™”ì  ì•ˆë‚´ âœ“
- ì¸µê°„ ì´ë™ í‘œì‹œ âœ“

ã€âš ï¸ ë¬¸ì œê°€ ìˆëŠ” ë¶€ë¶„ã€‘

1.4 ì„±ëŠ¥ ë¬¸ì œ
```python
# pathfinding.py
def find_path(self, start_node, end_node):
    # ë§¤ë²ˆ ì „ì²´ ê·¸ë˜í”„ë¥¼ ë©”ëª¨ë¦¬ì— ë¡œë“œ
    all_nodes = NavigationNode.objects.all()
    all_edges = NavigationEdge.objects.select_related('from_node', 'to_node').all()
    
    # O(VÂ²) ë³µì¡ë„ë¡œ ê·¸ë˜í”„ ì¬êµ¬ì¶•
    graph = self.build_graph(all_nodes, all_edges)
```
- ìºì‹± ì—†ìŒ âœ—
- ë§¤ë²ˆ DB ì „ì²´ ì¡°íšŒ âœ—
- ë©”ëª¨ë¦¬ ê³¼ë‹¤ ì‚¬ìš© âœ—

1.5 íœ´ë¦¬ìŠ¤í‹± í•¨ìˆ˜ í•œê³„
```python
def heuristic(self, node1, node2):
    # 2D ìœ í´ë¦¬ë“œ ê±°ë¦¬ë§Œ ì‚¬ìš©
    return math.sqrt(
        (node1.x_coord - node2.x_coord) ** 2 + 
        (node1.y_coord - node2.y_coord) ** 2
    )
    # ì¸µê°„ ê±°ë¦¬ ë¬´ì‹œ
    # ì‹¤ì œ ë³´í–‰ ì‹œê°„ ë¯¸ë°˜ì˜
```

1.6 ì¸µê°„ ì´ë™ ì²˜ë¦¬ ë¯¸í¡
```python
# z_coord í•„ë“œëŠ” ìˆì§€ë§Œ ì‚¬ìš© ì•ˆ í•¨
z_coord = models.FloatField(default=0)

# ì—˜ë¦¬ë² ì´í„° ëŒ€ê¸°ì‹œê°„ ë¯¸ê³ ë ¤
if edge.edge_type == 'elevator':
    # ë‹¨ìˆœíˆ ì´ë™ ì‹œê°„ë§Œ ì¶”ê°€
    walk_time = edge.walk_time
```

================================================================================
2. í”„ë¡ íŠ¸ì—”ë“œ ì§€ë„ ì‹œìŠ¤í…œ
================================================================================

ã€âœ… ì˜ êµ¬í˜„ëœ ë¶€ë¶„ã€‘

2.1 SVG ì§€ë„ ì‹œìŠ¤í…œ
```javascript
// InteractiveMapViewer.jsx
const InteractiveMapViewer = ({ mapSrc, currentLocation, destination }) => {
    const [svgContent, setSvgContent] = useState('');
    const [zoom, setZoom] = useState(1);
    const [pan, setPan] = useState({ x: 0, y: 0 });
    
    // SVG ë¡œë“œ ë° íŒŒì‹±
    useEffect(() => {
        fetch(mapSrc)
            .then(res => res.text())
            .then(text => {
                const parsed = parseSVG(text);
                setSvgContent(parsed);
            });
    }, [mapSrc]);
    
    // ì¤Œ/íŒ¬ ì œìŠ¤ì²˜ ì§€ì›
    const handlePinch = (e) => {
        setZoom(prev => Math.max(0.5, Math.min(3, prev * e.scale)));
    };
```
- ë²¡í„° ê¸°ë°˜ í™•ëŒ€/ì¶•ì†Œ âœ“
- í„°ì¹˜ ì œìŠ¤ì²˜ ì§€ì› âœ“
- ì¸í„°ë™í‹°ë¸Œ ìš”ì†Œ âœ“

2.2 ê²½ë¡œ ì• ë‹ˆë©”ì´ì…˜
```javascript
// MapNavigator.jsx
const animatePath = (pathElement) => {
    const length = pathElement.getTotalLength();
    
    pathElement.style.strokeDasharray = length;
    pathElement.style.strokeDashoffset = length;
    
    pathElement.animate([
        { strokeDashoffset: length },
        { strokeDashoffset: 0 }
    ], {
        duration: 2000,
        easing: 'ease-in-out'
    });
};
```
- ë¶€ë“œëŸ¬ìš´ ê²½ë¡œ ì• ë‹ˆë©”ì´ì…˜ âœ“
- ì§„í–‰ ìƒí™© ì‹œê°í™” âœ“

2.3 í˜„ì¬ ìœ„ì¹˜ í‘œì‹œ
```javascript
const CurrentLocationMarker = ({ x, y }) => (
    <g transform={`translate(${x}, ${y})`}>
        <circle r="8" fill="#4285F4" className="pulse-animation" />
        <circle r="12" fill="rgba(66, 133, 244, 0.3)" className="pulse-ring" />
    </g>
);
```
- í„ìŠ¤ ì• ë‹ˆë©”ì´ì…˜ âœ“
- ëª…í™•í•œ ì‹œê°ì  í‘œì‹œ âœ“

ã€âš ï¸ ë¬¸ì œê°€ ìˆëŠ” ë¶€ë¶„ã€‘

2.4 ë³´ì•ˆ ì·¨ì•½ì 
```javascript
// InteractiveMapViewer.jsx
<div dangerouslySetInnerHTML={{ __html: svgContent }} />
// XSS ê³µê²© ìœ„í—˜
```

2.5 ì„±ëŠ¥ ë¬¸ì œ
```javascript
// MapNavigator.jsx - 1000ì¤„ì´ ë„˜ëŠ” ê±°ëŒ€í•œ ì»´í¬ë„ŒíŠ¸
useEffect(() => {
    // ë§¤ë²ˆ SVGë¥¼ ìƒˆë¡œ íŒŒì‹±
    const parser = new DOMParser();
    const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');
    
    // DOM ì§ì ‘ ì¡°ì‘
    const rooms = svgDoc.querySelectorAll('[data-room-id]');
    rooms.forEach(room => {
        room.addEventListener('click', handleRoomClick);
    });
}, [mapSrc, highlightRoom, currentMapIndex]);
// ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ìœ„í—˜
```

2.6 ìºì‹± ë¶€ì¬
```javascript
// ë§¤ë²ˆ ë„¤íŠ¸ì›Œí¬ì—ì„œ SVG ë¡œë“œ
fetch(`/images/maps/${mapFile}`)
    .then(res => res.text())
// ìºì‹± ì „ëµ ì—†ìŒ
```

2.7 ë°˜ì‘í˜• ì´ìŠˆ
```css
/* SVG ë‚´ë¶€ í…ìŠ¤íŠ¸ê°€ ëª¨ë°”ì¼ì—ì„œ ë„ˆë¬´ ì‘ìŒ */
.room-label {
    font-size: 12px;  /* ê³ ì • í¬ê¸° */
}
```

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ”¥ ì£¼ìš” ë¬¸ì œì  ë° ì˜í–¥ë„
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ë¬¸ì œì                 â”‚ ì‹¬ê°ë„ â”‚ ì˜í–¥ ë²”ìœ„      â”‚ ìˆ˜ì • ì‹œê°„ â”‚ ìš°ì„ ìˆœìœ„ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ê²½ë¡œ ê³„ì‚° ì„±ëŠ¥        â”‚ ë†’ìŒ   â”‚ ì‘ë‹µ ì†ë„     â”‚ 2ì¼       â”‚ P1      â”‚
â”‚ XSS ë³´ì•ˆ ì·¨ì•½ì        â”‚ ë†’ìŒ   â”‚ ë³´ì•ˆ          â”‚ 1ì¼       â”‚ P1      â”‚
â”‚ SVG ë¡œë”© ì„±ëŠ¥         â”‚ ì¤‘ê°„   â”‚ ì´ˆê¸° ë¡œë”©     â”‚ 1ì¼       â”‚ P2      â”‚
â”‚ ì¸µê°„ ì´ë™ í‘œí˜„        â”‚ ì¤‘ê°„   â”‚ ì‚¬ìš©ì ê²½í—˜   â”‚ 2ì¼       â”‚ P2      â”‚
â”‚ ì ‘ê·¼ì„± ê²½ë¡œ ì²˜ë¦¬      â”‚ ì¤‘ê°„   â”‚ ì ‘ê·¼ì„±        â”‚ 2ì¼       â”‚ P2      â”‚
â”‚ ì»´í¬ë„ŒíŠ¸ ë³µì¡ë„       â”‚ ë‚®ìŒ   â”‚ ìœ ì§€ë³´ìˆ˜      â”‚ 3ì¼       â”‚ P3      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’¡ ê°œì„  ë°©ì•ˆ (ìš°ì„ ìˆœìœ„ìˆœ)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

================================================================================
[P1] ê²½ë¡œ ê³„ì‚° ì„±ëŠ¥ ìµœì í™” (2ì¼)
================================================================================

ã€ë°±ì—”ë“œ ìºì‹± êµ¬í˜„ã€‘
```python
# pathfinding.py
from django.core.cache import cache
import hashlib

class OptimizedPathfinder:
    def __init__(self):
        self.graph_cache_key = 'navigation_graph_v1'
        self.path_cache_timeout = 300  # 5ë¶„
        
    def get_cached_graph(self):
        """ìºì‹œëœ ê·¸ë˜í”„ ë˜ëŠ” ìƒˆë¡œ ìƒì„±"""
        graph = cache.get(self.graph_cache_key)
        
        if not graph:
            graph = self.build_graph()
            cache.set(self.graph_cache_key, graph, 3600)  # 1ì‹œê°„ ìºì‹±
            
        return graph
    
    def find_path(self, start_id, end_id, constraints=None):
        """ìºì‹±ëœ ê²½ë¡œ íƒìƒ‰"""
        # ìºì‹œ í‚¤ ìƒì„±
        cache_key = self.generate_cache_key(start_id, end_id, constraints)
        
        # ìºì‹œ í™•ì¸
        cached_path = cache.get(cache_key)
        if cached_path:
            return cached_path
        
        # ê·¸ë˜í”„ ë¡œë“œ
        graph = self.get_cached_graph()
        
        # A* ì•Œê³ ë¦¬ì¦˜ ì‹¤í–‰
        path = self.astar_search(graph, start_id, end_id, constraints)
        
        # ê²°ê³¼ ìºì‹±
        if path:
            cache.set(cache_key, path, self.path_cache_timeout)
        
        return path
    
    def generate_cache_key(self, start, end, constraints):
        """ê²½ë¡œ ìºì‹œ í‚¤ ìƒì„±"""
        key_data = f"{start}_{end}_{constraints}"
        return f"path_{hashlib.md5(key_data.encode()).hexdigest()}"
```

ã€í”„ë¡ íŠ¸ì—”ë“œ ë©”ëª¨ì´ì œì´ì…˜ã€‘
```javascript
// hooks/useMapData.js
import { useMemo, useCallback } from 'react';

const useMapData = (mapSrc) => {
    const [svgCache, setSvgCache] = useState({});
    
    const loadSVG = useCallback(async (src) => {
        // ìºì‹œ í™•ì¸
        if (svgCache[src]) {
            return svgCache[src];
        }
        
        // ë¡œë“œ ë° íŒŒì‹±
        const response = await fetch(src);
        const text = await response.text();
        const parsed = parseSVGSafely(text);
        
        // ìºì‹œ ì €ì¥
        setSvgCache(prev => ({
            ...prev,
            [src]: parsed
        }));
        
        return parsed;
    }, [svgCache]);
    
    return { loadSVG };
};
```

================================================================================
[P1] XSS ë³´ì•ˆ ì·¨ì•½ì  ìˆ˜ì • (1ì¼)
================================================================================

ã€ì•ˆì „í•œ SVG ë Œë”ë§ã€‘
```javascript
// components/SafeSVGViewer.jsx
import DOMPurify from 'dompurify';

const SafeSVGViewer = ({ svgContent, onElementClick }) => {
    const svgRef = useRef(null);
    
    useEffect(() => {
        if (!svgContent || !svgRef.current) return;
        
        // SVG ì½˜í…ì¸  ì •í™”
        const clean = DOMPurify.sanitize(svgContent, {
            USE_PROFILES: { svg: true },
            ADD_TAGS: ['use'],
            ADD_ATTR: ['href', 'data-room-id', 'data-interactive']
        });
        
        // React ì»´í¬ë„ŒíŠ¸ë¡œ íŒŒì‹±
        const parser = new DOMParser();
        const svgDoc = parser.parseFromString(clean, 'image/svg+xml');
        
        // ì´ë²¤íŠ¸ ìœ„ì„ìœ¼ë¡œ ì²˜ë¦¬
        svgRef.current.innerHTML = '';
        svgRef.current.appendChild(svgDoc.documentElement);
        
    }, [svgContent]);
    
    const handleClick = (e) => {
        const roomId = e.target.closest('[data-room-id]')?.dataset.roomId;
        if (roomId && onElementClick) {
            onElementClick(roomId);
        }
    };
    
    return (
        <div 
            ref={svgRef}
            onClick={handleClick}
            className="svg-container"
        />
    );
};
```

================================================================================
[P2] SVG ë¡œë”© ì„±ëŠ¥ ê°œì„  (1ì¼)
================================================================================

ã€í”„ë¦¬ë¡œë”© ë° ë ˆì´ì§€ ë¡œë”©ã€‘
```javascript
// services/mapPreloader.js
class MapPreloader {
    constructor() {
        this.cache = new Map();
        this.preloadQueue = [];
    }
    
    async preloadMaps(mapList) {
        // ì¤‘ìš”ë„ ìˆœìœ¼ë¡œ ì •ë ¬
        const sorted = mapList.sort((a, b) => a.priority - b.priority);
        
        // ë³‘ë ¬ ë¡œë”© (ìµœëŒ€ 3ê°œ)
        const chunks = [];
        for (let i = 0; i < sorted.length; i += 3) {
            chunks.push(sorted.slice(i, i + 3));
        }
        
        for (const chunk of chunks) {
            await Promise.all(
                chunk.map(map => this.loadMap(map.src))
            );
        }
    }
    
    async loadMap(src) {
        if (this.cache.has(src)) {
            return this.cache.get(src);
        }
        
        const response = await fetch(src);
        const text = await response.text();
        
        // SVG ìµœì í™”
        const optimized = this.optimizeSVG(text);
        
        this.cache.set(src, optimized);
        return optimized;
    }
    
    optimizeSVG(svgText) {
        // ë¶ˆí•„ìš”í•œ ë©”íƒ€ë°ì´í„° ì œê±°
        let optimized = svgText.replace(/<metadata>[\s\S]*?<\/metadata>/gi, '');
        
        // ê³µë°± ìµœì†Œí™”
        optimized = optimized.replace(/\s+/g, ' ');
        
        // ID ë‹¨ìˆœí™”
        optimized = optimized.replace(/id="[^"]{50,}"/g, (match) => {
            const shortId = 'id_' + Math.random().toString(36).substr(2, 9);
            return `id="${shortId}"`;
        });
        
        return optimized;
    }
}
```

================================================================================
[P2] ì¸µê°„ ì´ë™ ê°œì„  (2ì¼)
================================================================================

ã€3D ì¢Œí‘œê³„ êµ¬í˜„ã€‘
```python
# models.py
class FloorConnection(models.Model):
    """ì¸µê°„ ì—°ê²° ëª¨ë¸"""
    connection_type = models.CharField(max_length=20)  # elevator, stairs, escalator
    from_floor = models.IntegerField()
    to_floor = models.IntegerField()
    building = models.CharField(max_length=100)
    avg_wait_time = models.FloatField(default=30)  # ì´ˆ
    is_operational = models.BooleanField(default=True)
    capacity = models.IntegerField(default=10)
    
    def get_current_wait_time(self):
        """ì‹¤ì‹œê°„ ëŒ€ê¸°ì‹œê°„ ê³„ì‚°"""
        base_wait = self.avg_wait_time
        
        # ì‹œê°„ëŒ€ë³„ ê°€ì¤‘ì¹˜
        current_hour = timezone.now().hour
        if 8 <= current_hour <= 10 or 17 <= current_hour <= 19:
            return base_wait * 1.5  # ëŸ¬ì‹œì•„ì›Œ
        
        return base_wait

# pathfinding.py
def calculate_3d_distance(node1, node2):
    """3D ê±°ë¦¬ ê³„ì‚°"""
    horizontal = math.sqrt(
        (node1.x_coord - node2.x_coord) ** 2 + 
        (node1.y_coord - node2.y_coord) ** 2
    )
    
    vertical = abs(node1.z_coord - node2.z_coord) * 3  # ì¸µê³  3m
    
    # ì¸µê°„ ì´ë™ í˜ë„í‹°
    if node1.floor != node2.floor:
        floor_penalty = 20  # ì¸µê°„ ì´ë™ ì¶”ê°€ ì‹œê°„
        return horizontal + vertical + floor_penalty
    
    return horizontal
```

ã€í”„ë¡ íŠ¸ì—”ë“œ 3D í‘œí˜„ã€‘
```javascript
// components/Floor3DNavigator.jsx
const Floor3DNavigator = ({ path, currentFloor }) => {
    const renderFloorTransition = (fromFloor, toFloor, method) => {
        return (
            <div className="floor-transition">
                <div className="from-floor">
                    {fromFloor}ì¸µ
                </div>
                <div className="transition-method">
                    {method === 'elevator' ? 'ğŸ›—' : 'ğŸªœ'}
                </div>
                <div className="to-floor">
                    {toFloor}ì¸µ
                </div>
                <div className="instruction">
                    {method === 'elevator' 
                        ? `ì—˜ë¦¬ë² ì´í„°ë¥¼ íƒ€ê³  ${toFloor}ì¸µìœ¼ë¡œ ì´ë™`
                        : `ê³„ë‹¨ì„ ì´ìš©í•´ ${toFloor}ì¸µìœ¼ë¡œ ì´ë™`}
                </div>
            </div>
        );
    };
    
    return (
        <div className="3d-navigator">
            {path.map((step, index) => {
                if (step.floorChange) {
                    return renderFloorTransition(
                        step.fromFloor,
                        step.toFloor,
                        step.method
                    );
                }
                return renderNormalStep(step);
            })}
        </div>
    );
};
```

================================================================================
[P2] ì ‘ê·¼ì„± ê²½ë¡œ ì²˜ë¦¬ (2ì¼)
================================================================================

ã€ì ‘ê·¼ì„± í”„ë¡œí•„ ì‹œìŠ¤í…œã€‘
```python
# models.py
class AccessibilityProfile(models.Model):
    """ì‚¬ìš©ìë³„ ì ‘ê·¼ì„± ìš”êµ¬ì‚¬í•­"""
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    
    # ì´ë™ ë³´ì¡°
    mobility_aid = models.CharField(max_length=20, choices=[
        ('none', 'ì—†ìŒ'),
        ('wheelchair', 'íœ ì²´ì–´'),
        ('walker', 'ë³´í–‰ê¸°'),
        ('crutches', 'ëª©ë°œ'),
        ('cane', 'ì§€íŒ¡ì´')
    ])
    
    # ê°ê° ì¥ì• 
    vision_level = models.CharField(max_length=20, choices=[
        ('normal', 'ì •ìƒ'),
        ('low_vision', 'ì €ì‹œë ¥'),
        ('blind', 'ì „ë§¹')
    ])
    hearing_level = models.CharField(max_length=20, choices=[
        ('normal', 'ì •ìƒ'),
        ('hard_of_hearing', 'ë‚œì²­'),
        ('deaf', 'ì²­ê°ì¥ì• ')
    ])
    
    # ë¬¼ë¦¬ì  ì œì•½
    max_walking_distance = models.IntegerField(default=500)  # ë¯¸í„°
    max_slope = models.FloatField(default=8.0)  # í¼ì„¼íŠ¸
    min_door_width = models.IntegerField(default=80)  # ì„¼í‹°ë¯¸í„°
    needs_elevator = models.BooleanField(default=False)
    needs_rest_areas = models.BooleanField(default=False)

# pathfinding.py
class AccessiblePathfinder:
    def find_accessible_path(self, start, end, profile):
        """ì ‘ê·¼ì„± ìš”êµ¬ì‚¬í•­ì„ ê³ ë ¤í•œ ê²½ë¡œ íƒìƒ‰"""
        constraints = self.build_constraints(profile)
        
        # ì—£ì§€ í•„í„°ë§
        def is_edge_accessible(edge):
            if profile.needs_elevator and edge.edge_type == 'stairs':
                return False
            
            if profile.mobility_aid == 'wheelchair':
                if not edge.is_wheelchair_accessible:
                    return False
                if edge.slope > profile.max_slope:
                    return False
            
            if edge.min_width < profile.min_door_width:
                return False
            
            return True
        
        # ìˆ˜ì •ëœ A* ì•Œê³ ë¦¬ì¦˜
        path = self.astar_with_constraints(
            start, end,
            edge_filter=is_edge_accessible,
            max_distance=profile.max_walking_distance
        )
        
        # íœ´ê²Œì†Œ ì¶”ê°€
        if profile.needs_rest_areas:
            path = self.add_rest_stops(path, profile.max_walking_distance / 3)
        
        return path
```

ã€í”„ë¡ íŠ¸ì—”ë“œ ì ‘ê·¼ì„± UIã€‘
```javascript
// components/AccessibilitySettings.jsx
const AccessibilitySettings = ({ onProfileUpdate }) => {
    const [profile, setProfile] = useState({
        mobilityAid: 'none',
        visionLevel: 'normal',
        hearingLevel: 'normal',
        needsElevator: false,
        needsRestAreas: false
    });
    
    const handleSave = async () => {
        await api.post('/api/v1/users/accessibility-profile/', profile);
        onProfileUpdate(profile);
        
        // ì ‘ê·¼ì„± ëª¨ë“œ UI ì ìš©
        document.body.classList.add(`accessibility-${profile.mobilityAid}`);
        
        // ìŒì„± ì•ˆë‚´ í™œì„±í™”
        if (profile.visionLevel !== 'normal') {
            enableVoiceGuidance();
        }
    };
    
    return (
        <div className="accessibility-settings">
            <h3>ì ‘ê·¼ì„± ì„¤ì •</h3>
            
            <label>
                ì´ë™ ë³´ì¡° ê¸°êµ¬
                <select 
                    value={profile.mobilityAid}
                    onChange={e => setProfile({...profile, mobilityAid: e.target.value})}
                >
                    <option value="none">ì—†ìŒ</option>
                    <option value="wheelchair">íœ ì²´ì–´</option>
                    <option value="walker">ë³´í–‰ê¸°</option>
                    <option value="cane">ì§€íŒ¡ì´</option>
                </select>
            </label>
            
            <label>
                <input 
                    type="checkbox"
                    checked={profile.needsElevator}
                    onChange={e => setProfile({...profile, needsElevator: e.target.checked})}
                />
                ì—˜ë¦¬ë² ì´í„°ë§Œ ì‚¬ìš©
            </label>
            
            <label>
                <input 
                    type="checkbox"
                    checked={profile.needsRestAreas}
                    onChange={e => setProfile({...profile, needsRestAreas: e.target.checked})}
                />
                ì¤‘ê°„ íœ´ê²Œì†Œ í•„ìš”
            </label>
            
            <button onClick={handleSave}>ì €ì¥</button>
        </div>
    );
};
```

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“Š ê°œì„  í›„ ì˜ˆìƒ íš¨ê³¼
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ã€ì„±ëŠ¥ í–¥ìƒã€‘
â€¢ ê²½ë¡œ ê³„ì‚° ì†ë„ 500ms â†’ 50ms (10ë°°)
â€¢ SVG ë¡œë”© ì‹œê°„ 2ì´ˆ â†’ 0.5ì´ˆ (4ë°°)
â€¢ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ 30% ê°ì†Œ

ã€ì •í™•ë„ ê°œì„ ã€‘
â€¢ ê²½ë¡œ ì˜ˆì¸¡ ì •í™•ë„ 70% â†’ 90%
â€¢ ì¸µê°„ ì´ë™ ì‹œê°„ ì˜¤ì°¨ Â±5ë¶„ â†’ Â±1ë¶„
â€¢ í˜¼ì¡ ì‹œê°„ëŒ€ ë°˜ì˜ìœ¼ë¡œ ì‹¤ì œ ë„ì°© ì‹œê°„ ì¼ì¹˜ìœ¨ í–¥ìƒ

ã€ì ‘ê·¼ì„±ã€‘
â€¢ íœ ì²´ì–´ ì‚¬ìš©ì ê²½ë¡œ 100% ì§€ì›
â€¢ ì‹œê°ì¥ì• ì¸ ìŒì„± ì•ˆë‚´
â€¢ ì²­ê°ì¥ì• ì¸ ì‹œê° ì•Œë¦¼

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âœ… ì²´í¬ë¦¬ìŠ¤íŠ¸
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ã€í•„ìˆ˜ êµ¬í˜„ (1ì£¼ ë‚´)ã€‘
â–¡ ê²½ë¡œ ê³„ì‚° ìºì‹±
â–¡ XSS ì·¨ì•½ì  ìˆ˜ì •
â–¡ SVG í”„ë¦¬ë¡œë”©
â–¡ ê¸°ë³¸ ì ‘ê·¼ì„± ì§€ì›

ã€ì„ íƒ êµ¬í˜„ (ì—¬ìœ  ìˆì„ ë•Œ)ã€‘
â–¡ 3D ì¢Œí‘œê³„ ì™„ì„±
â–¡ ì‹¤ì‹œê°„ í˜¼ì¡ë„ ë°˜ì˜
â–¡ ìŒì„± ë„¤ë¹„ê²Œì´ì…˜
â–¡ AR ê²½ë¡œ ì•ˆë‚´

ã€í…ŒìŠ¤íŠ¸ í•­ëª©ã€‘
â–¡ ê²½ë¡œ ê³„ì‚° ì •í™•ë„
â–¡ ë‹¤ì–‘í•œ ë””ë°”ì´ìŠ¤ í˜¸í™˜ì„±
â–¡ ì ‘ê·¼ì„± ì‹œë‚˜ë¦¬ì˜¤
â–¡ ì„±ëŠ¥ ë²¤ì¹˜ë§ˆí¬
â–¡ ë³´ì•ˆ ì·¨ì•½ì  ìŠ¤ìº”

================================================================================
ê²°ë¡ : ì§€ë„ ë° ê²½ë¡œ ì•ˆë‚´ ì‹œìŠ¤í…œì€ ê¸°ë³¸ ê¸°ëŠ¥ì€ êµ¬í˜„ë˜ì—ˆìœ¼ë‚˜,
     ì„±ëŠ¥ ìµœì í™”ì™€ ì ‘ê·¼ì„± ê°•í™”ê°€ ì‹œê¸‰í•¨
================================================================================