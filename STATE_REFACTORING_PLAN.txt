# 환자 상태/큐 상태 리팩토링 계획서
생성일: 2025-01-03
작성자: Claude

## 현황 분석 요약

### 현재 상태 시스템 (3중 구조)
1. **PatientState.current_state** (9단계 환자 여정)
   - UNREGISTERED → ARRIVED → REGISTERED → WAITING → CALLED → ONGOING → COMPLETED → PAYMENT → FINISHED
   
2. **Queue.state** (7단계 대기열 상태)
   - waiting → called → ongoing → completed / delayed / no_show / cancelled
   
3. **Appointment.status** (4+α 예약 상태)
   - waiting, ongoing, done, delayed + completed, scheduled, examined

### 발견된 주요 문제점

#### 1. 상태 모델 불일치
- 3개 모델이 서로 다른 상태값 사용
- 동일 의미의 상태가 다른 이름으로 표현 (ongoing vs in_progress)
- 매핑 로직이 여러 곳에 산재하고 일관성 없음

#### 2. 상태 매핑 로직 문제
**Frontend (journeyStore.js)**
```javascript
// 라인 489-590: 복잡한 상태 계산 로직
if (profileState === 'REGISTERED' || profileState === 'WAITING') {
    const ongoingQueue = currentQueues.find(q => q.state === 'ongoing');
    if (ongoingQueue) computedState = 'ONGOING';
}

// 라인 757-758: 또 다른 매핑
status: queue.state === 'waiting' ? 'waiting' : 
        queue.state === 'called' ? 'ongoing' : queue.state
```

**Backend (integrations/views.py)**
```python
# 일방향 매핑만 존재
queue_to_patient_state = {
    'waiting': 'WAITING',
    'called': 'CALLED',
    'ongoing': 'ONGOING',
    'completed': 'COMPLETED'
}
```

#### 3. API 엔드포인트 혼재
- `/api/v1/auth/profile/` - 환자 프로필과 상태
- `/api/v1/appointments/today` - 당일 예약과 상태
- `/api/v1/queue/my-position` - 대기열 상태
- `/api/v1/virtual-db/patient/` - EMR 동기화 상태
- 각 API가 다른 형태로 상태 정보 반환

#### 4. 상태 동기화 문제
- Queue 변경 시 PatientState 자동 업데이트 없음
- WebSocket과 폴링이 동시에 작동하여 경합 발생
- 상태 불일치 시 우선순위 불명확

#### 5. 코드 중복 및 복잡도
- 상태 확인 로직이 20개 이상 컴포넌트에 중복
- 같은 조건을 다른 방식으로 체크
- 테스트 데이터와 실제 데이터 혼재

## 해결 방안: Option B - 명확한 역할 분리

### 설계 원칙
1. **PatientState**: 환자의 전체 병원 여정 상태 (9단계)
2. **Queue.state**: 대기열 내에서만 유효한 세부 상태
3. **명확한 매핑 규칙과 양방향 동기화**

### Phase 1: 상태 모델 정의 및 통일 (1주차)

#### 1.1 Backend 상태 정의
```python
# common/constants.py (새 파일)
from enum import Enum

class PatientJourneyState(Enum):
    """환자 전체 여정 상태 (최상위)"""
    UNREGISTERED = 'UNREGISTERED'  # 병원 도착 전
    ARRIVED = 'ARRIVED'            # 병원 도착, NFC 태그
    REGISTERED = 'REGISTERED'      # 접수/로그인 완료
    WAITING = 'WAITING'            # 대기 중
    CALLED = 'CALLED'              # 호출됨
    ONGOING = 'ONGOING'            # 진행 중
    COMPLETED = 'COMPLETED'        # 완료
    PAYMENT = 'PAYMENT'            # 수납
    FINISHED = 'FINISHED'          # 귀가

class QueueDetailState(Enum):
    """대기열 세부 상태 (WAITING~COMPLETED 구간에서만 유효)"""
    ACTIVE_WAITING = 'active_waiting'     # 정상 대기
    DELAYED_WAITING = 'delayed_waiting'   # 지연 대기
    CALLED = 'called'                     # 호출됨
    NO_SHOW = 'no_show'                  # 미방문
    IN_PROGRESS = 'in_progress'           # 진행 중
    COMPLETED = 'completed'               # 완료
    CANCELLED = 'cancelled'               # 취소

# 상태 매핑 규칙
STATE_MAPPING = {
    # Queue Detail → Patient Journey
    'active_waiting': 'WAITING',
    'delayed_waiting': 'WAITING',
    'called': 'CALLED',
    'no_show': 'WAITING',  # 또는 별도 처리
    'in_progress': 'ONGOING',
    'completed': 'COMPLETED',
    'cancelled': 'COMPLETED'  # 또는 별도 처리
}
```

#### 1.2 Frontend 상태 정의
```typescript
// types/states.ts (새 파일)
export enum PatientJourneyState {
    UNREGISTERED = 'UNREGISTERED',
    ARRIVED = 'ARRIVED',
    REGISTERED = 'REGISTERED',
    WAITING = 'WAITING',
    CALLED = 'CALLED',
    ONGOING = 'ONGOING',
    COMPLETED = 'COMPLETED',
    PAYMENT = 'PAYMENT',
    FINISHED = 'FINISHED'
}

export enum QueueDetailState {
    ACTIVE_WAITING = 'active_waiting',
    DELAYED_WAITING = 'delayed_waiting',
    CALLED = 'called',
    NO_SHOW = 'no_show',
    IN_PROGRESS = 'in_progress',
    COMPLETED = 'completed',
    CANCELLED = 'cancelled'
}

// 상태 매핑 유틸리티
export const mapQueueToJourney = (queueState: QueueDetailState): PatientJourneyState => {
    const mapping = {
        [QueueDetailState.ACTIVE_WAITING]: PatientJourneyState.WAITING,
        [QueueDetailState.DELAYED_WAITING]: PatientJourneyState.WAITING,
        [QueueDetailState.CALLED]: PatientJourneyState.CALLED,
        [QueueDetailState.NO_SHOW]: PatientJourneyState.WAITING,
        [QueueDetailState.IN_PROGRESS]: PatientJourneyState.ONGOING,
        [QueueDetailState.COMPLETED]: PatientJourneyState.COMPLETED,
        [QueueDetailState.CANCELLED]: PatientJourneyState.COMPLETED
    };
    return mapping[queueState];
};
```

### Phase 2: API 통합 및 정규화 (2주차)

#### 2.1 통합 상태 API 생성
```python
# p_queue/views.py
class PatientJourneyViewSet(viewsets.ViewSet):
    """환자 여정 상태 통합 관리 API"""
    
    @action(detail=False, methods=['GET'])
    def current_state(self, request):
        """현재 환자의 통합 상태 조회"""
        user = request.user
        
        # PatientState 조회
        patient_state = PatientState.objects.get(user=user)
        
        # 활성 Queue 조회
        active_queues = Queue.objects.filter(
            user=user, 
            state__in=['active_waiting', 'delayed_waiting', 'called', 'in_progress']
        )
        
        # 당일 Appointments 조회
        today_appointments = Appointment.objects.filter(
            user=user,
            scheduled_at__date=timezone.now().date()
        )
        
        return Response({
            'journey_state': patient_state.current_state,
            'queue_details': QueueSerializer(active_queues, many=True).data,
            'appointments': AppointmentSerializer(today_appointments, many=True).data,
            'next_action': self.calculate_next_action(patient_state, active_queues),
            'timestamp': timezone.now()
        })
    
    @action(detail=False, methods=['POST'])
    def update_state(self, request):
        """상태 업데이트 (트랜잭션으로 원자성 보장)"""
        new_state = request.data.get('state')
        trigger_type = request.data.get('trigger_type')
        
        with transaction.atomic():
            # PatientState 업데이트
            patient_state = PatientState.objects.select_for_update().get(user=request.user)
            old_state = patient_state.current_state
            patient_state.current_state = new_state
            patient_state.save()
            
            # Queue 업데이트 (필요시)
            if new_state in ['WAITING', 'CALLED', 'ONGOING', 'COMPLETED']:
                queue = Queue.objects.select_for_update().filter(
                    user=request.user,
                    state__in=['active_waiting', 'called', 'in_progress']
                ).first()
                
                if queue:
                    queue.state = self.map_journey_to_queue(new_state)
                    queue.save()
            
            # StateTransition 로그
            StateTransition.objects.create(
                user=request.user,
                from_state=old_state,
                to_state=new_state,
                trigger_type=trigger_type
            )
            
            # WebSocket 알림
            self.send_state_update_notification(request.user, new_state)
            
        return Response({'success': True, 'new_state': new_state})
```

#### 2.2 Frontend API 서비스 통합
```javascript
// api/patientJourneyService.js (새 파일)
import { apiClient } from './client';

export const PatientJourneyAPI = {
    // 통합 상태 조회
    getCurrentState: async () => {
        const response = await apiClient.get('/api/v1/patient-journey/current-state/');
        return response.data;
    },
    
    // 상태 업데이트
    updateState: async (newState, triggerType) => {
        const response = await apiClient.post('/api/v1/patient-journey/update-state/', {
            state: newState,
            trigger_type: triggerType
        });
        return response.data;
    },
    
    // WebSocket 구독
    subscribeToStateUpdates: (callback) => {
        const ws = new WebSocket(`${WS_BASE_URL}/ws/patient-journey/`);
        ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            callback(data);
        };
        return ws;
    }
};
```

### Phase 3: 상태 동기화 메커니즘 (3주차)

#### 3.1 Django Signals로 자동 동기화
```python
# p_queue/signals.py
from django.db.models.signals import post_save
from django.dispatch import receiver

@receiver(post_save, sender=Queue)
def sync_queue_to_patient_state(sender, instance, created, **kwargs):
    """Queue 변경 시 PatientState 자동 동기화"""
    if not created:  # 업데이트인 경우만
        patient_state = PatientState.objects.get(user=instance.user)
        
        # 매핑 규칙 적용
        new_journey_state = map_queue_to_journey(instance.state)
        
        if patient_state.current_state != new_journey_state:
            patient_state.current_state = new_journey_state
            patient_state.save()
            
            # 상태 전환 로그
            StateTransition.objects.create(
                user=instance.user,
                from_state=patient_state.current_state,
                to_state=new_journey_state,
                trigger_type='queue_sync'
            )

@receiver(post_save, sender=PatientState)
def sync_patient_state_to_queue(sender, instance, created, **kwargs):
    """PatientState 변경 시 Queue 동기화 (필요한 경우만)"""
    if instance.current_state in ['WAITING', 'CALLED', 'ONGOING', 'COMPLETED']:
        active_queue = Queue.objects.filter(
            user=instance.user,
            state__in=['active_waiting', 'called', 'in_progress']
        ).first()
        
        if active_queue:
            new_queue_state = map_journey_to_queue(instance.current_state)
            if active_queue.state != new_queue_state:
                active_queue.state = new_queue_state
                active_queue.save()
```

#### 3.2 Frontend 실시간 동기화
```javascript
// hooks/usePatientJourney.js (새 파일)
import { useState, useEffect, useCallback } from 'react';
import { PatientJourneyAPI } from '../api/patientJourneyService';

export const usePatientJourney = () => {
    const [journeyState, setJourneyState] = useState(null);
    const [queueDetails, setQueueDetails] = useState(null);
    const [loading, setLoading] = useState(true);
    const [wsConnection, setWsConnection] = useState(null);
    
    // 초기 로드
    useEffect(() => {
        loadCurrentState();
        
        // WebSocket 연결
        const ws = PatientJourneyAPI.subscribeToStateUpdates((data) => {
            setJourneyState(data.journey_state);
            setQueueDetails(data.queue_details);
        });
        
        setWsConnection(ws);
        
        return () => {
            if (ws) ws.close();
        };
    }, []);
    
    const loadCurrentState = async () => {
        try {
            setLoading(true);
            const data = await PatientJourneyAPI.getCurrentState();
            setJourneyState(data.journey_state);
            setQueueDetails(data.queue_details);
        } catch (error) {
            console.error('Failed to load patient state:', error);
        } finally {
            setLoading(false);
        }
    };
    
    const updateState = useCallback(async (newState, triggerType) => {
        try {
            await PatientJourneyAPI.updateState(newState, triggerType);
            // WebSocket이 자동으로 상태 업데이트를 전달함
        } catch (error) {
            console.error('Failed to update state:', error);
            throw error;
        }
    }, []);
    
    return {
        journeyState,
        queueDetails,
        loading,
        updateState,
        refresh: loadCurrentState,
        isConnected: wsConnection?.readyState === WebSocket.OPEN
    };
};
```

### Phase 4: 컴포넌트 리팩토링 (4주차)

#### 4.1 JourneyStore 단순화
```javascript
// store/journeyStore.js (리팩토링)
import { create } from 'zustand';
import { PatientJourneyAPI } from '../api/patientJourneyService';
import { PatientJourneyState, QueueDetailState } from '../types/states';

const useJourneyStore = create((set, get) => ({
    // 상태
    journeyState: PatientJourneyState.UNREGISTERED,
    queueDetails: null,
    appointments: [],
    loading: false,
    error: null,
    
    // 액션
    fetchCurrentState: async () => {
        set({ loading: true, error: null });
        try {
            const data = await PatientJourneyAPI.getCurrentState();
            set({
                journeyState: data.journey_state,
                queueDetails: data.queue_details,
                appointments: data.appointments,
                loading: false
            });
        } catch (error) {
            set({ error: error.message, loading: false });
        }
    },
    
    updateJourneyState: async (newState, triggerType) => {
        try {
            await PatientJourneyAPI.updateState(newState, triggerType);
            // WebSocket이 상태 업데이트를 처리
        } catch (error) {
            set({ error: error.message });
            throw error;
        }
    },
    
    // 계산된 값
    getCurrentScreen: () => {
        const state = get().journeyState;
        // 상태별 화면 매핑 (단순화)
        const screenMap = {
            [PatientJourneyState.UNREGISTERED]: 'UnregisteredScreen',
            [PatientJourneyState.ARRIVED]: 'ArrivedScreen',
            [PatientJourneyState.REGISTERED]: 'RegisteredScreen',
            [PatientJourneyState.WAITING]: 'WaitingScreen',
            [PatientJourneyState.CALLED]: 'WaitingScreen',
            [PatientJourneyState.ONGOING]: 'WaitingScreen',
            [PatientJourneyState.COMPLETED]: 'CompletedScreen',
            [PatientJourneyState.PAYMENT]: 'PaymentScreen',
            [PatientJourneyState.FINISHED]: 'FinishedScreen'
        };
        return screenMap[state];
    },
    
    getQueueInfo: () => {
        const queue = get().queueDetails?.[0];
        if (!queue) return null;
        
        return {
            position: queue.queue_number,
            estimatedWait: queue.estimated_wait_time,
            isDelayed: queue.state === QueueDetailState.DELAYED_WAITING,
            isCalled: queue.state === QueueDetailState.CALLED,
            isInProgress: queue.state === QueueDetailState.IN_PROGRESS
        };
    }
}));

export default useJourneyStore;
```

#### 4.2 컴포넌트 단순화 예시
```javascript
// components/JourneyContainer.jsx (리팩토링)
import React from 'react';
import useJourneyStore from '../store/journeyStore';
import { PatientJourneyState } from '../types/states';

// Screen imports
import UnregisteredScreen from './screens/UnregisteredScreen';
import ArrivedScreen from './screens/ArrivedScreen';
// ... 기타 스크린

const JourneyContainer = () => {
    const { journeyState, getCurrentScreen } = useJourneyStore();
    
    // 화면 컴포넌트 매핑 (더 단순하게)
    const screens = {
        [PatientJourneyState.UNREGISTERED]: UnregisteredScreen,
        [PatientJourneyState.ARRIVED]: ArrivedScreen,
        [PatientJourneyState.REGISTERED]: RegisteredScreen,
        [PatientJourneyState.WAITING]: WaitingScreen,
        [PatientJourneyState.CALLED]: WaitingScreen,
        [PatientJourneyState.ONGOING]: WaitingScreen,
        [PatientJourneyState.COMPLETED]: CompletedScreen,
        [PatientJourneyState.PAYMENT]: PaymentScreen,
        [PatientJourneyState.FINISHED]: FinishedScreen
    };
    
    const ScreenComponent = screens[journeyState] || UnregisteredScreen;
    
    return <ScreenComponent />;
};

export default JourneyContainer;
```

### Phase 5: 테스트 및 마이그레이션 (5주차)

#### 5.1 데이터 마이그레이션
```python
# p_queue/migrations/00XX_unify_state_values.py
from django.db import migrations

def migrate_states(apps, schema_editor):
    Queue = apps.get_model('p_queue', 'Queue')
    PatientState = apps.get_model('p_queue', 'PatientState')
    
    # Queue state 마이그레이션
    state_mapping = {
        'waiting': 'active_waiting',
        'called': 'called',
        'ongoing': 'in_progress',
        'completed': 'completed',
        'delayed': 'delayed_waiting',
        'no_show': 'no_show',
        'cancelled': 'cancelled'
    }
    
    for old_state, new_state in state_mapping.items():
        Queue.objects.filter(state=old_state).update(state=new_state)
    
    # PatientState는 그대로 유지 (이미 명확함)

class Migration(migrations.Migration):
    dependencies = [
        ('p_queue', '00XX_previous_migration'),
    ]
    
    operations = [
        migrations.RunPython(migrate_states),
    ]
```

#### 5.2 테스트 계획
```python
# tests/test_state_synchronization.py
import pytest
from django.test import TestCase
from p_queue.models import Queue, PatientState

class StatesynchronizationTest(TestCase):
    def test_queue_update_syncs_patient_state(self):
        """Queue 상태 변경이 PatientState에 반영되는지 테스트"""
        user = create_test_user()
        patient_state = PatientState.objects.create(
            user=user, 
            current_state='WAITING'
        )
        queue = Queue.objects.create(
            user=user,
            state='active_waiting',
            exam_id='exam1'
        )
        
        # Queue를 'called'로 변경
        queue.state = 'called'
        queue.save()
        
        # PatientState가 'CALLED'로 변경되었는지 확인
        patient_state.refresh_from_db()
        assert patient_state.current_state == 'CALLED'
    
    def test_patient_state_update_syncs_queue(self):
        """PatientState 변경이 Queue에 반영되는지 테스트"""
        # ... 역방향 동기화 테스트
    
    def test_concurrent_updates_handled_correctly(self):
        """동시 업데이트 시 일관성 유지 테스트"""
        # ... 동시성 테스트
```

### Phase 6: 모니터링 및 개선 (6주차)

#### 6.1 상태 불일치 모니터링
```python
# management/commands/check_state_consistency.py
from django.core.management.base import BaseCommand
from p_queue.models import Queue, PatientState

class Command(BaseCommand):
    help = '상태 불일치 체크'
    
    def handle(self, *args, **options):
        inconsistencies = []
        
        for patient_state in PatientState.objects.all():
            user = patient_state.user
            active_queue = Queue.objects.filter(
                user=user,
                state__in=['active_waiting', 'called', 'in_progress']
            ).first()
            
            if active_queue:
                expected_journey = map_queue_to_journey(active_queue.state)
                if patient_state.current_state != expected_journey:
                    inconsistencies.append({
                        'user': user.id,
                        'patient_state': patient_state.current_state,
                        'queue_state': active_queue.state,
                        'expected': expected_journey
                    })
        
        if inconsistencies:
            self.stdout.write(self.style.ERROR(
                f'Found {len(inconsistencies)} inconsistencies'
            ))
            for item in inconsistencies:
                self.stdout.write(str(item))
        else:
            self.stdout.write(self.style.SUCCESS('All states are consistent'))
```

#### 6.2 대시보드 모니터링
- 상태 불일치 실시간 알림
- 상태 전환 통계 대시보드
- 평균 상태 전환 시간 분석

## 구현 우선순위 및 일정

### Week 1-2: Phase 1 & 2
- [ ] Backend 상태 모델 통일
- [ ] Frontend 타입 정의
- [ ] 통합 API 개발

### Week 3-4: Phase 3 & 4
- [ ] 동기화 메커니즘 구현
- [ ] 컴포넌트 리팩토링
- [ ] WebSocket 통합

### Week 5-6: Phase 5 & 6
- [ ] 데이터 마이그레이션
- [ ] 테스트 작성 및 실행
- [ ] 모니터링 도구 구축
- [ ] 문서화

## 리스크 및 대응 방안

### 리스크 1: 기존 시스템 호환성
- **대응**: 점진적 마이그레이션, 기존 API 임시 유지

### 리스크 2: 데이터 일관성 손실
- **대응**: 트랜잭션 사용, 백업 및 롤백 계획

### 리스크 3: 성능 저하
- **대응**: 캐싱 전략, 인덱스 최적화

### 리스크 4: 사용자 혼란
- **대응**: 단계적 배포, A/B 테스트

## 성공 지표

1. **상태 불일치율**: < 0.1%
2. **API 응답 시간**: < 200ms
3. **WebSocket 연결 안정성**: > 99%
4. **코드 중복 제거율**: > 80%
5. **테스트 커버리지**: > 90%

## 참고 문서

- API 명세서 v3.0.0
- Django Signals 문서
- WebSocket 프로토콜 명세
- React 상태 관리 베스트 프랙티스

---
END OF DOCUMENT