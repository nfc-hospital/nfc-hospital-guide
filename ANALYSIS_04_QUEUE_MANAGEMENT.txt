================================================================================
ê¸°ëŠ¥ë³„ ìƒì„¸ ë¶„ì„ ë³´ê³ ì„œ #4: ëŒ€ê¸°ì—´ ê´€ë¦¬ ì‹œìŠ¤í…œ
================================================================================
ì‘ì„±ì¼: 2025ë…„ 1ì›” 9ì¼
ë¶„ì„ ë²”ìœ„: ë°±ì—”ë“œ + í”„ë¡ íŠ¸ì—”ë“œ í†µí•©
í˜„ì¬ ì™„ì„±ë„: 80%
================================================================================

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ ê´€ë ¨ íŒŒì¼ êµ¬ì¡°
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ã€ë°±ì—”ë“œã€‘
backend/nfc_hospital_system/p_queue/
â”œâ”€â”€ models.py                    # Queue, QueueStatusLog ëª¨ë¸
â”œâ”€â”€ views.py                     # ëŒ€ê¸°ì—´ ê´€ë¦¬ API
â”œâ”€â”€ serializers.py               # ëŒ€ê¸°ì—´ ì‹œë¦¬ì–¼ë¼ì´ì €
â”œâ”€â”€ signals.py                   # ëŒ€ê¸°ì—´ ë³€ê²½ ì‹œê·¸ë„
â”œâ”€â”€ consumers.py                 # WebSocket ì»¨ìŠˆë¨¸
â””â”€â”€ urls.py                      # API ì—”ë“œí¬ì¸íŠ¸

backend/nfc_hospital_system/admin_dashboard/
â””â”€â”€ views.py                     # ê´€ë¦¬ì ëŒ€ê¸°ì—´ ì œì–´ API

ã€í”„ë¡ íŠ¸ì—”ë“œã€‘
frontend-pwa/src/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ WaitingStatus.jsx       # ëŒ€ê¸° ìƒíƒœ í‘œì‹œ
â”‚   â”œâ”€â”€ WaitingInfo.jsx         # ëŒ€ê¸° ì •ë³´ ìƒì„¸
â”‚   â””â”€â”€ journey/
â”‚       â””â”€â”€ QueueStatus.jsx     # ëŒ€ê¸°ì—´ ìƒíƒœ ì¹´ë“œ
â”œâ”€â”€ hooks/
â”‚   â””â”€â”€ useRealtimeQueues.js    # ì‹¤ì‹œê°„ ëŒ€ê¸°ì—´ í›…
â”œâ”€â”€ pages/
â”‚   â””â”€â”€ WaitingScreen.jsx       # ëŒ€ê¸° í™”ë©´
â””â”€â”€ components/admin/dashboard/
    â””â”€â”€ OperationalMonitor.jsx   # ê´€ë¦¬ì ëŒ€ê¸°ì—´ ëª¨ë‹ˆí„°

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ” í˜„ì¬ êµ¬í˜„ ìƒíƒœ ë¶„ì„
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

================================================================================
1. ë°±ì—”ë“œ ëŒ€ê¸°ì—´ ì‹œìŠ¤í…œ
================================================================================

ã€âœ… ì˜ êµ¬í˜„ëœ ë¶€ë¶„ã€‘

1.1 Queue ëª¨ë¸ (ë‹¨ì¼ ì§„ì‹¤ ì›ì²œ)
```python
class Queue(models.Model):
    queue_id = models.UUIDField(primary_key=True, default=uuid.uuid4)
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    exam = models.ForeignKey(Exam, on_delete=models.CASCADE)
    appointment = models.ForeignKey(Appointment)
    
    state = models.CharField(choices=QUEUE_STATE_CHOICES)  # 7ë‹¨ê³„ ìƒíƒœ
    queue_number = models.IntegerField()                   # ëŒ€ê¸° ìˆœë²ˆ
    estimated_wait_time = models.IntegerField()            # ì˜ˆìƒ ëŒ€ê¸°ì‹œê°„(ë¶„)
    priority = models.CharField(choices=PRIORITY_CHOICES)  # ìš°ì„ ìˆœìœ„
    
    called_at = models.DateTimeField(null=True)           # í˜¸ì¶œ ì‹œê°„
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
```
- UUID ê¸°ë°˜ ê³ ìœ  ì‹ë³„ì âœ“
- ê²€ì‚¬ì‹¤ë³„ ë…ë¦½ ëŒ€ê¸°ì—´ âœ“
- ìš°ì„ ìˆœìœ„ ì‹œìŠ¤í…œ ì§€ì› âœ“
- ì‹œê°„ ì¶”ì  í•„ë“œ ì™„ë¹„ âœ“

1.2 ëŒ€ê¸°ì—´ ìƒíƒœ ê´€ë¦¬
```python
QUEUE_STATE_CHOICES = [
    ('waiting', 'Waiting'),         # ëŒ€ê¸° ì¤‘
    ('delayed', 'Delayed'),         # ì§€ì—°
    ('called', 'Called'),           # í˜¸ì¶œë¨
    ('no_show', 'No Show'),        # ë¯¸ì¶œì„
    ('in_progress', 'In Progress'), # ì§„í–‰ ì¤‘
    ('completed', 'Completed'),     # ì™„ë£Œ
    ('cancelled', 'Cancelled'),     # ì·¨ì†Œ
]
```
- ì„¸ë¶„í™”ëœ ìƒíƒœ ì¶”ì  âœ“
- ì˜ˆì™¸ ìƒí™© ì²˜ë¦¬ (no_show, cancelled) âœ“

1.3 ëŒ€ê¸°ì—´ ë³€ê²½ ì´ë ¥ ê´€ë¦¬
```python
class QueueStatusLog(models.Model):
    queue = models.ForeignKey(Queue)
    previous_state = models.CharField(null=True)
    new_state = models.CharField()
    previous_number = models.IntegerField(null=True)
    new_number = models.IntegerField(null=True)
    reason = models.CharField(max_length=200)
    changed_by = models.ForeignKey(User, null=True)
    created_at = models.DateTimeField(auto_now_add=True)
```
- ëª¨ë“  ë³€ê²½ ì‚¬í•­ ì¶”ì  âœ“
- ë³€ê²½ ì‚¬ìœ  ê¸°ë¡ âœ“
- ê°ì‚¬ ì¶”ì  ê°€ëŠ¥ âœ“

1.4 ëŒ€ê¸° ìˆœì„œ ê³„ì‚° (MyPositionView)
```python
def get_queue_position(self, queue):
    ahead_count = 0
    
    # 1. Emergency í™˜ì ìˆ˜
    ahead_count += Queue.objects.filter(
        exam=queue.exam,
        state='waiting',
        priority='emergency'
    ).count()
    
    # 2. Urgent í™˜ì ì¤‘ ì•ìˆœì„œ
    if queue.priority == 'urgent':
        ahead_count += Queue.objects.filter(
            exam=queue.exam,
            state='waiting',
            priority='urgent',
            queue_number__lt=queue.queue_number
        ).count()
    
    # 3. Normal í™˜ì ì²˜ë¦¬
    # ... ë³µì¡í•œ 1:2 ê·œì¹™ ì ìš©
```
- ìš°ì„ ìˆœìœ„ë³„ ì„¸ë°€í•œ ê³„ì‚° âœ“
- ê³µì •í•œ ëŒ€ê¸° ìˆœì„œ ë³´ì¥ âœ“

ã€âš ï¸ ë¬¸ì œê°€ ìˆëŠ” ë¶€ë¶„ã€‘

1.5 ëŒ€ê¸°ì‹œê°„ ì˜ˆì¸¡ ë¶€ì •í™•
```python
def recalculate_wait_times(self):
    base_wait_time = 15  # ê³ ì •ê°’ ì‚¬ìš©
    
    for queue in waiting_queues:
        if queue.priority == 'emergency':
            current_wait += base_wait_time * 0.5
        elif queue.priority == 'urgent':
            current_wait += base_wait_time * 0.75
        else:
            current_wait += base_wait_time
```
- ê³ ì •ëœ 15ë¶„ ê¸°ì¤€ âœ—
- ì‹¤ì œ ì²˜ë¦¬ ì‹œê°„ ë¯¸ë°˜ì˜ âœ—
- ì˜ë£Œì§„ ì†ë„ ì°¨ì´ ë¬´ì‹œ âœ—

1.6 N+1 ì¿¼ë¦¬ ë¬¸ì œ
```python
# views.py - QueueListView
for queue in queues:
    queue.exam  # ì¶”ê°€ ì¿¼ë¦¬ ë°œìƒ
    queue.user  # ì¶”ê°€ ì¿¼ë¦¬ ë°œìƒ
    queue.appointment  # ì¶”ê°€ ì¿¼ë¦¬ ë°œìƒ
```
- select_related ë¯¸ì‚¬ìš© âœ—
- ì„±ëŠ¥ ì €í•˜ ì›ì¸ âœ—

1.7 ì‹¤ì‹œê°„ ë™ê¸°í™” ë¯¸í¡
```python
# WebSocket êµ¬í˜„ ë¶ˆì™„ì „
class QueueConsumer(AsyncWebsocketConsumer):
    async def receive(self, text_data):
        # ê¸°ë³¸ êµ¬í˜„ë§Œ ì¡´ì¬
        pass
```

================================================================================
2. í”„ë¡ íŠ¸ì—”ë“œ ëŒ€ê¸°ì—´ ì‹œìŠ¤í…œ
================================================================================

ã€âœ… ì˜ êµ¬í˜„ëœ ë¶€ë¶„ã€‘

2.1 WaitingStatus ì»´í¬ë„ŒíŠ¸
```javascript
const WaitingStatus = ({ queue }) => {
    // ìƒíƒœë³„ ìƒ‰ìƒ ë° ì•„ì´ì½˜
    const getStatusStyle = (status) => {
        switch(status) {
            case 'waiting': return { color: 'blue', icon: <Clock /> };
            case 'called': return { color: 'green', icon: <Bell /> };
            case 'in_progress': return { color: 'orange', icon: <Activity /> };
            // ...
        }
    };
    
    // ì˜ˆìƒ í˜¸ì¶œ ì‹œê°„ ê³„ì‚°
    const estimatedCallTime = useMemo(() => {
        const now = new Date();
        now.setMinutes(now.getMinutes() + queue.estimated_wait_time);
        return now.toLocaleTimeString();
    }, [queue.estimated_wait_time]);
```
- ì§ê´€ì ì¸ ì‹œê°í™” âœ“
- ì‹¤ì‹œê°„ ì‹œê°„ ê³„ì‚° âœ“
- ìƒíƒœë³„ ëª…í™•í•œ êµ¬ë¶„ âœ“

2.2 ì‹¤ì‹œê°„ ëŒ€ê¸°ì—´ í›…
```javascript
const useRealtimeQueues = (examId) => {
    const [queues, setQueues] = useState([]);
    const [myPosition, setMyPosition] = useState(null);
    
    useEffect(() => {
        // 10ì´ˆë§ˆë‹¤ ì—…ë°ì´íŠ¸
        const interval = setInterval(fetchQueues, 10000);
        
        // ë¸Œë¼ìš°ì € ì•Œë¦¼ ê¶Œí•œ
        if ('Notification' in window) {
            Notification.requestPermission();
        }
        
        return () => clearInterval(interval);
    }, []);
    
    // í˜¸ì¶œ ì‹œ ì•Œë¦¼
    const notifyIfCalled = (newState) => {
        if (newState === 'called' && Notification.permission === 'granted') {
            new Notification('í˜¸ì¶œë˜ì—ˆìŠµë‹ˆë‹¤!', {
                body: 'ê²€ì‚¬ì‹¤ë¡œ ì™€ì£¼ì„¸ìš”.',
                icon: '/icon-192x192.png'
            });
        }
    };
```
- ì£¼ê¸°ì  ì—…ë°ì´íŠ¸ âœ“
- ë¸Œë¼ìš°ì € ì•Œë¦¼ ì§€ì› âœ“
- ìƒíƒœ ë³€ê²½ ê°ì§€ âœ“

2.3 ê´€ë¦¬ì ëŒ€ê¸°ì—´ ëª¨ë‹ˆí„°
```javascript
// OperationalMonitor.jsx
const OperationalMonitor = () => {
    const [departments, setDepartments] = useState([]);
    
    const fetchRealTimeData = async () => {
        const response = await api.get('/queue/dashboard/realtime-data/');
        setDepartments(response.data.departments);
    };
    
    return (
        <div className="grid grid-cols-3 gap-4">
            {departments.map(dept => (
                <DepartmentCard
                    key={dept.id}
                    waitingCount={dept.waiting_count}
                    avgWaitTime={dept.avg_wait_time}
                    staffCount={dept.active_staff}
                />
            ))}
        </div>
    );
};
```
- ë¶€ì„œë³„ í˜„í™© í‘œì‹œ âœ“
- ì‹¤ì‹œê°„ í†µê³„ âœ“
- ì§ê´€ì ì¸ ëŒ€ì‹œë³´ë“œ âœ“

ã€âš ï¸ ë¬¸ì œê°€ ìˆëŠ” ë¶€ë¶„ã€‘

2.4 í´ë§ ë°©ì‹ì˜ ë¹„íš¨ìœ¨ì„±
```javascript
// 10ì´ˆë§ˆë‹¤ ì „ì²´ ë°ì´í„° ì¬ìš”ì²­
setInterval(fetchQueues, 10000);
// WebSocket ë¯¸ì‚¬ìš©ìœ¼ë¡œ ë¦¬ì†ŒìŠ¤ ë‚­ë¹„
```

2.5 ì—ëŸ¬ ì²˜ë¦¬ ë¶€ì¡±
```javascript
const fetchQueues = async () => {
    try {
        const response = await api.get('/queues/');
        setQueues(response.data);
    } catch (error) {
        console.error(error);
        // ì¬ì‹œë„ ë¡œì§ ì—†ìŒ
        // ì‚¬ìš©ì ì•Œë¦¼ ì—†ìŒ
    }
};
```

2.6 ìƒíƒœ ë§¤í•‘ í•˜ë“œì½”ë”©
```javascript
// ë°±ì—”ë“œ ìƒíƒœì™€ 1:1 í•˜ë“œì½”ë”©
const statusMap = {
    'waiting': 'ëŒ€ê¸° ì¤‘',
    'called': 'í˜¸ì¶œë¨',
    // ... í™•ì¥ì„± ë¶€ì¡±
};
```

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ”¥ ì£¼ìš” ë¬¸ì œì  ë° ì˜í–¥ë„
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ë¬¸ì œì                 â”‚ ì‹¬ê°ë„ â”‚ ì˜í–¥ ë²”ìœ„      â”‚ ìˆ˜ì • ì‹œê°„ â”‚ ìš°ì„ ìˆœìœ„ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ëŒ€ê¸°ì‹œê°„ ì˜ˆì¸¡ ë¶€ì •í™•  â”‚ ë†’ìŒ   â”‚ ì‚¬ìš©ì ì‹ ë¢°   â”‚ 2ì¼       â”‚ P1      â”‚
â”‚ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ ì§€ì—°  â”‚ ë†’ìŒ   â”‚ UX            â”‚ 2ì¼       â”‚ P1      â”‚
â”‚ N+1 ì¿¼ë¦¬ ë¬¸ì œ        â”‚ ì¤‘ê°„   â”‚ ì„±ëŠ¥          â”‚ 1ì¼       â”‚ P2      â”‚
â”‚ í´ë§ ë°©ì‹ ë¹„íš¨ìœ¨     â”‚ ì¤‘ê°„   â”‚ ì„œë²„ ë¶€í•˜     â”‚ 1ì¼       â”‚ P2      â”‚
â”‚ ì—ëŸ¬ ì²˜ë¦¬ ë¶€ì¡±       â”‚ ë‚®ìŒ   â”‚ ì•ˆì •ì„±        â”‚ 0.5ì¼     â”‚ P3      â”‚
â”‚ ìš°ì„ ìˆœìœ„ ê³„ì‚° ë³µì¡   â”‚ ë‚®ìŒ   â”‚ ìœ ì§€ë³´ìˆ˜      â”‚ 1ì¼       â”‚ P3      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’¡ ê°œì„  ë°©ì•ˆ (ìš°ì„ ìˆœìœ„ìˆœ)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

================================================================================
[P1] ëŒ€ê¸°ì‹œê°„ ì˜ˆì¸¡ ì •í™•ë„ ê°œì„  (2ì¼)
================================================================================

ã€ë°±ì—”ë“œ - ì‹¤ì œ ë°ì´í„° ê¸°ë°˜ ì˜ˆì¸¡ã€‘
```python
# models.py - Queue ëª¨ë¸ ê°œì„ 
class Queue(models.Model):
    # ê¸°ì¡´ í•„ë“œ...
    
    def calculate_dynamic_wait_time(self):
        """ìµœê·¼ ì²˜ë¦¬ ì‹œê°„ ê¸°ë°˜ ë™ì  ì˜ˆì¸¡"""
        # 1. ê°™ì€ ê²€ì‚¬ì˜ ìµœê·¼ 30ê±´ ì²˜ë¦¬ ì‹œê°„
        recent_logs = QueueStatusLog.objects.filter(
            queue__exam=self.exam,
            new_state='completed',
            created_at__gte=timezone.now() - timedelta(days=7)
        ).select_related('queue')
        
        # 2. ì‹¤ì œ ì²˜ë¦¬ ì‹œê°„ ê³„ì‚°
        processing_times = []
        for log in recent_logs:
            if log.queue.called_at:
                duration = (log.created_at - log.queue.called_at).total_seconds() / 60
                processing_times.append(duration)
        
        # 3. í†µê³„ ê¸°ë°˜ ì˜ˆì¸¡
        if processing_times:
            avg_time = statistics.mean(processing_times)
            std_dev = statistics.stdev(processing_times) if len(processing_times) > 1 else 0
            
            # ìš°ì„ ìˆœìœ„ë³„ ê°€ì¤‘ì¹˜
            if self.priority == 'emergency':
                avg_time *= 0.7  # ê¸´ê¸‰ í™˜ìëŠ” ë¹ ë¥´ê²Œ ì²˜ë¦¬
            elif self.priority == 'urgent':
                avg_time *= 0.85
            
            # í‘œì¤€í¸ì°¨ ê³ ë ¤í•œ ë²„í¼
            buffer = std_dev * 0.5
            
            return int(avg_time + buffer)
        
        # ê¸°ë³¸ê°’ (ë°ì´í„° ë¶€ì¡± ì‹œ)
        return self.exam.average_duration or 15
    
    def get_estimated_call_time(self):
        """ì˜ˆìƒ í˜¸ì¶œ ì‹œê°„ ê³„ì‚°"""
        ahead_queues = Queue.objects.filter(
            exam=self.exam,
            state='waiting',
            created_at__lt=self.created_at
        ).order_by('priority', 'queue_number')
        
        total_wait = 0
        for queue in ahead_queues:
            total_wait += queue.calculate_dynamic_wait_time()
        
        return timezone.now() + timedelta(minutes=total_wait)
```

ã€ML ê¸°ë°˜ ì˜ˆì¸¡ (ì„ íƒì )ã€‘
```python
# services/wait_time_predictor.py
import joblib
from sklearn.ensemble import RandomForestRegressor

class WaitTimePredictor:
    def __init__(self):
        self.model = self.load_or_train_model()
    
    def predict(self, queue):
        """ë¨¸ì‹ ëŸ¬ë‹ ê¸°ë°˜ ëŒ€ê¸°ì‹œê°„ ì˜ˆì¸¡"""
        features = self.extract_features(queue)
        prediction = self.model.predict([features])[0]
        return max(5, int(prediction))  # ìµœì†Œ 5ë¶„
    
    def extract_features(self, queue):
        """ì˜ˆì¸¡ìš© íŠ¹ì§• ì¶”ì¶œ"""
        return [
            queue.exam.average_duration,
            self.get_current_load(queue.exam),
            self.get_time_of_day_factor(),
            self.get_day_of_week_factor(),
            self.get_staff_efficiency(queue.exam),
            queue.priority == 'emergency',
            queue.priority == 'urgent',
        ]
    
    def train_model(self):
        """ê³¼ê±° ë°ì´í„°ë¡œ ëª¨ë¸ í•™ìŠµ"""
        # ìµœê·¼ 30ì¼ ë°ì´í„°
        completed_queues = Queue.objects.filter(
            state='completed',
            updated_at__gte=timezone.now() - timedelta(days=30)
        )
        
        X, y = [], []
        for queue in completed_queues:
            if queue.called_at:
                features = self.extract_features(queue)
                actual_wait = (queue.called_at - queue.created_at).total_seconds() / 60
                X.append(features)
                y.append(actual_wait)
        
        model = RandomForestRegressor(n_estimators=100)
        model.fit(X, y)
        
        # ëª¨ë¸ ì €ì¥
        joblib.dump(model, 'wait_time_model.pkl')
        return model
```

================================================================================
[P1] ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ ê°œì„  (2ì¼)
================================================================================

ã€ë°±ì—”ë“œ - WebSocket êµ¬í˜„ ê°•í™”ã€‘
```python
# consumers.py
from channels.generic.websocket import AsyncJsonWebsocketConsumer

class QueueConsumer(AsyncJsonWebsocketConsumer):
    async def connect(self):
        self.user = self.scope['user']
        self.exam_groups = set()
        
        # í™˜ìê°€ ëŒ€ê¸° ì¤‘ì¸ ëª¨ë“  ê²€ì‚¬ì‹¤ êµ¬ë…
        queues = await self.get_user_queues()
        for queue in queues:
            group_name = f'exam_{queue.exam_id}'
            self.exam_groups.add(group_name)
            await self.channel_layer.group_add(group_name, self.channel_name)
        
        await self.accept()
        
        # ì—°ê²° ì‹œ í˜„ì¬ ìƒíƒœ ì „ì†¡
        await self.send_current_status()
    
    async def receive_json(self, content):
        """í´ë¼ì´ì–¸íŠ¸ ë©”ì‹œì§€ ì²˜ë¦¬"""
        message_type = content.get('type')
        
        if message_type == 'ping':
            await self.send_json({'type': 'pong'})
        elif message_type == 'subscribe_exam':
            exam_id = content.get('exam_id')
            await self.subscribe_to_exam(exam_id)
    
    async def queue_update(self, event):
        """ëŒ€ê¸°ì—´ ì—…ë°ì´íŠ¸ ë¸Œë¡œë“œìºìŠ¤íŠ¸"""
        await self.send_json({
            'type': 'queue_update',
            'queue_id': event['queue_id'],
            'state': event['state'],
            'position': event['position'],
            'estimated_wait': event['estimated_wait'],
            'timestamp': event['timestamp']
        })
    
    async def patient_called(self, event):
        """í™˜ì í˜¸ì¶œ ì•Œë¦¼"""
        await self.send_json({
            'type': 'patient_called',
            'exam_name': event['exam_name'],
            'room': event['room'],
            'message': 'ê²€ì‚¬ì‹¤ë¡œ ì™€ì£¼ì„¸ìš”',
            'priority': 'high'
        })

# signals.py - ìë™ WebSocket ì•Œë¦¼
from django.db.models.signals import post_save
from django.dispatch import receiver
from channels.layers import get_channel_layer
from asgiref.sync import async_to_sync

@receiver(post_save, sender=Queue)
def notify_queue_update(sender, instance, created, **kwargs):
    """Queue ë³€ê²½ ì‹œ ìë™ WebSocket ì•Œë¦¼"""
    if not created and instance.tracker.has_changed('state'):
        channel_layer = get_channel_layer()
        group_name = f'exam_{instance.exam_id}'
        
        async_to_sync(channel_layer.group_send)(
            group_name,
            {
                'type': 'queue_update',
                'queue_id': str(instance.queue_id),
                'state': instance.state,
                'position': instance.get_position(),
                'estimated_wait': instance.estimated_wait_time,
                'timestamp': timezone.now().isoformat()
            }
        )
        
        # í˜¸ì¶œ ì‹œ íŠ¹ë³„ ì•Œë¦¼
        if instance.state == 'called':
            async_to_sync(channel_layer.group_send)(
                f'user_{instance.user_id}',
                {
                    'type': 'patient_called',
                    'exam_name': instance.exam.title,
                    'room': instance.exam.room,
                }
            )
```

ã€í”„ë¡ íŠ¸ì—”ë“œ - WebSocket í´ë¼ì´ì–¸íŠ¸ã€‘
```javascript
// hooks/useQueueWebSocket.js
import { useEffect, useRef, useState } from 'react';

const useQueueWebSocket = (examId) => {
    const ws = useRef(null);
    const [queueData, setQueueData] = useState(null);
    const [connectionStatus, setConnectionStatus] = useState('disconnected');
    const reconnectAttempts = useRef(0);
    
    const connect = () => {
        const wsUrl = `ws://localhost:8000/ws/queue/`;
        ws.current = new WebSocket(wsUrl);
        
        ws.current.onopen = () => {
            console.log('Queue WebSocket connected');
            setConnectionStatus('connected');
            reconnectAttempts.current = 0;
            
            // ê²€ì‚¬ì‹¤ êµ¬ë…
            ws.current.send(JSON.stringify({
                type: 'subscribe_exam',
                exam_id: examId
            }));
        };
        
        ws.current.onmessage = (event) => {
            const data = JSON.parse(event.data);
            
            switch(data.type) {
                case 'queue_update':
                    handleQueueUpdate(data);
                    break;
                    
                case 'patient_called':
                    handlePatientCalled(data);
                    break;
                    
                case 'pong':
                    // ì—°ê²° ìœ ì§€ í™•ì¸
                    break;
            }
        };
        
        ws.current.onerror = (error) => {
            console.error('WebSocket error:', error);
            setConnectionStatus('error');
        };
        
        ws.current.onclose = () => {
            setConnectionStatus('disconnected');
            scheduleReconnect();
        };
    };
    
    const handleQueueUpdate = (data) => {
        setQueueData(prev => ({
            ...prev,
            state: data.state,
            position: data.position,
            estimatedWait: data.estimated_wait,
            lastUpdate: data.timestamp
        }));
        
        // ì§„ë™ ì•Œë¦¼ (ëª¨ë°”ì¼)
        if ('vibrate' in navigator && data.state === 'called') {
            navigator.vibrate([200, 100, 200]);
        }
    };
    
    const handlePatientCalled = (data) => {
        // ë¸Œë¼ìš°ì € ì•Œë¦¼
        if ('Notification' in window && Notification.permission === 'granted') {
            new Notification('í˜¸ì¶œ ì•Œë¦¼', {
                body: `${data.exam_name} ${data.room}ë¡œ ì™€ì£¼ì„¸ìš”`,
                icon: '/icon-192x192.png',
                badge: '/badge-72x72.png',
                vibrate: [200, 100, 200],
                requireInteraction: true
            });
        }
        
        // ìŒì„± ì•Œë¦¼ (TTS)
        if ('speechSynthesis' in window) {
            const utterance = new SpeechSynthesisUtterance(
                `${data.exam_name} ê²€ì‚¬ì‹¤ë¡œ ì™€ì£¼ì„¸ìš”`
            );
            utterance.lang = 'ko-KR';
            speechSynthesis.speak(utterance);
        }
        
        // UI ì—…ë°ì´íŠ¸
        setQueueData(prev => ({
            ...prev,
            state: 'called',
            calledAt: new Date().toISOString()
        }));
    };
    
    const scheduleReconnect = () => {
        if (reconnectAttempts.current < 5) {
            const delay = Math.min(1000 * Math.pow(2, reconnectAttempts.current), 30000);
            setTimeout(() => {
                reconnectAttempts.current++;
                connect();
            }, delay);
        }
    };
    
    // Heartbeat
    useEffect(() => {
        const interval = setInterval(() => {
            if (ws.current?.readyState === WebSocket.OPEN) {
                ws.current.send(JSON.stringify({ type: 'ping' }));
            }
        }, 30000);
        
        return () => clearInterval(interval);
    }, []);
    
    useEffect(() => {
        connect();
        
        return () => {
            ws.current?.close();
        };
    }, [examId]);
    
    return { queueData, connectionStatus };
};
```

================================================================================
[P2] ì¿¼ë¦¬ ìµœì í™” (1ì¼)
================================================================================

ã€N+1 ë¬¸ì œ í•´ê²°ã€‘
```python
# views.py
class QueueListView(generics.ListAPIView):
    def get_queryset(self):
        # select_relatedë¡œ JOIN ì¿¼ë¦¬ ìµœì í™”
        return Queue.objects.filter(
            user=self.request.user,
            state__in=['waiting', 'called', 'in_progress']
        ).select_related(
            'exam',
            'appointment',
            'user'
        ).prefetch_related(
            'queuestatuslog_set'  # ë¡œê·¸ë„ í•œë²ˆì— ê°€ì ¸ì˜¤ê¸°
        ).order_by('priority', 'queue_number')

# ëŒ€ëŸ‰ ì—…ë°ì´íŠ¸ ìµœì í™”
def bulk_update_wait_times(exam_id):
    """ëŒ€ëŸ‰ ëŒ€ê¸°ì‹œê°„ ì—…ë°ì´íŠ¸"""
    with transaction.atomic():
        queues = list(Queue.objects.filter(
            exam_id=exam_id,
            state='waiting'
        ).select_for_update())  # ë½ ê±¸ê¸°
        
        current_time = 0
        updates = []
        
        for queue in queues:
            queue.estimated_wait_time = current_time
            current_time += queue.calculate_dynamic_wait_time()
            updates.append(queue)
        
        # í•œë²ˆì— ì—…ë°ì´íŠ¸
        Queue.objects.bulk_update(updates, ['estimated_wait_time'])
```

================================================================================
[P3] ì—ëŸ¬ ì²˜ë¦¬ ë° ë³µêµ¬ (0.5ì¼)
================================================================================

ã€í”„ë¡ íŠ¸ì—”ë“œ ì—ëŸ¬ ì²˜ë¦¬ã€‘
```javascript
// hooks/useRealtimeQueues.js
const useRealtimeQueues = (examId) => {
    const [error, setError] = useState(null);
    const [retryCount, setRetryCount] = useState(0);
    const maxRetries = 3;
    
    const fetchQueues = async () => {
        try {
            const response = await api.get(`/queues/?exam=${examId}`);
            setQueues(response.data);
            setError(null);
            setRetryCount(0);
        } catch (err) {
            setError(err);
            
            // ìë™ ì¬ì‹œë„
            if (retryCount < maxRetries) {
                const delay = Math.pow(2, retryCount) * 1000;
                setTimeout(() => {
                    setRetryCount(prev => prev + 1);
                    fetchQueues();
                }, delay);
            } else {
                // ì˜¤í”„ë¼ì¸ ëª¨ë“œ
                loadFromCache();
            }
        }
    };
    
    const loadFromCache = () => {
        const cached = localStorage.getItem(`queue_${examId}`);
        if (cached) {
            setQueues(JSON.parse(cached));
            setError({ type: 'offline', message: 'ì˜¤í”„ë¼ì¸ ëª¨ë“œ' });
        }
    };
    
    return { queues, error, retry: fetchQueues };
};
```

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“Š ê°œì„  í›„ ì˜ˆìƒ íš¨ê³¼
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ã€ì˜ˆì¸¡ ì •í™•ë„ã€‘
â€¢ ëŒ€ê¸°ì‹œê°„ ì˜ˆì¸¡ ì •í™•ë„ 60% â†’ 85%
â€¢ í™˜ì ë§Œì¡±ë„ 30% í–¥ìƒ
â€¢ ë¶ˆí•„ìš”í•œ ë¬¸ì˜ 50% ê°ì†Œ

ã€ì„±ëŠ¥ ê°œì„ ã€‘
â€¢ API ì‘ë‹µ ì†ë„ 3ë°° í–¥ìƒ
â€¢ ì„œë²„ ë¶€í•˜ 40% ê°ì†Œ
â€¢ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ ì§€ì—° 10ì´ˆ â†’ 0.5ì´ˆ

ã€ì•ˆì •ì„±ã€‘
â€¢ ë„¤íŠ¸ì›Œí¬ ì¥ì•  ë³µêµ¬ìœ¨ 95%
â€¢ ì—ëŸ¬ ë°œìƒë¥  70% ê°ì†Œ
â€¢ ë°ì´í„° ì¼ê´€ì„± 99.9% ë³´ì¥

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âœ… ì²´í¬ë¦¬ìŠ¤íŠ¸
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ã€í•„ìˆ˜ êµ¬í˜„ (1ì£¼ ë‚´)ã€‘
â–¡ ë™ì  ëŒ€ê¸°ì‹œê°„ ê³„ì‚°
â–¡ WebSocket ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
â–¡ ì¿¼ë¦¬ ìµœì í™” (select_related)
â–¡ ì—ëŸ¬ ì²˜ë¦¬ ê°•í™”

ã€ì„ íƒ êµ¬í˜„ (ì—¬ìœ  ìˆì„ ë•Œ)ã€‘
â–¡ ML ê¸°ë°˜ ì˜ˆì¸¡ ëª¨ë¸
â–¡ ìŒì„±/ì§„ë™ ì•Œë¦¼
â–¡ ì˜¤í”„ë¼ì¸ ëª¨ë“œ
â–¡ ëŒ€ê¸°ì—´ ì¬ë°°ì¹˜ ìë™í™”

ã€í…ŒìŠ¤íŠ¸ í•­ëª©ã€‘
â–¡ ëŒ€ê¸°ì‹œê°„ ì˜ˆì¸¡ ì •í™•ë„
â–¡ WebSocket ì—°ê²° ì•ˆì •ì„±
â–¡ ë™ì‹œ ì ‘ì† ë¶€í•˜ í…ŒìŠ¤íŠ¸
â–¡ ìš°ì„ ìˆœìœ„ ì²˜ë¦¬ ì •í™•ì„±
â–¡ ì—ëŸ¬ ë³µêµ¬ ì‹œë‚˜ë¦¬ì˜¤

================================================================================
ê²°ë¡ : ëŒ€ê¸°ì—´ ê´€ë¦¬ ì‹œìŠ¤í…œì€ ê¸°ë³¸ ê¸°ëŠ¥ì€ ì™„ì„±ë˜ì—ˆìœ¼ë‚˜,
     ì˜ˆì¸¡ ì •í™•ë„ì™€ ì‹¤ì‹œê°„ì„± ê°œì„ ì´ ì‹œê¸‰í•¨
================================================================================