# 환자 위치 시스템 현황 분석 보고서
생성일: 2025-01-03
작성자: Claude

=====================================================
## 📍 핵심 문제: 위치 데이터의 5중 표현 방식 혼재
=====================================================

현재 시스템에서 환자 위치를 표현하는 방식이 **최소 5가지** 이상 혼재되어 있으며,
각각 다른 구조와 형식을 사용하여 심각한 불일치와 중복 문제 발생

### 🚨 위치 표현 방식 분류

1. **UUID 방식** (36자리 문자열)
   - PatientState.current_location
   - QueueStatusLog.location  
   - StateTransition.location_at_transition
   - 예시: "123e4567-e89b-12d3-a456-426614174000"

2. **좌표계 방식** (x, y 숫자값)
   - NFCTag: x_coord (Float), y_coord (Float)
   - Exam: x_coord (Float), y_coord (Float)
   - Frontend: x_coord, y_coord (때로는 Integer로 사용)
   - 범위: 0.0 ~ 900.0 (스케일 기준 불명확)

3. **건물/층/호실 방식** (텍스트 조합)
   - NFCTag: building, floor (Int), room
   - Exam: building, floor (String), room
   - 예시: "본관", "2", "201호"

4. **태그 ID 참조 방식**
   - tag_id (UUID)
   - tag_uid (하드웨어 고유값)
   - code (병원 정의 코드)

5. **검사 ID 참조 방식**
   - exam_id를 통한 간접 위치 참조
   - 검사실 위치 = 환자 위치로 추정

=====================================================
## 📊 Backend 위치 데이터 구조 상세 분석
=====================================================

### 1. PatientState 모델 (p_queue/models.py)
```python
class PatientState(models.Model):
    # 라인 377: UUID 형식 위치 (어디를 가리키는지 불명확)
    current_location = models.CharField(max_length=36, null=True, blank=True)
    
    # 라인 380-389: 검사 참조 (위치 간접 표현)
    current_exam = models.ForeignKey('appointments.Exam', ...)
```
**문제점**:
- current_location이 UUID인데 어떤 테이블의 ID인지 불명확
- NFCTag.tag_id인지, 임의 location_id인지 모호
- current_exam과 current_location의 관계 불명확

### 2. QueueStatusLog 모델 (p_queue/models.py)
```python
class QueueStatusLog(models.Model):
    # 라인 332-337: 또 다른 UUID 형식 위치
    location = models.CharField(
        max_length=36, 
        null=True, 
        blank=True, 
        verbose_name='변경 시점 위치'
    )
```
**문제점**:
- PatientState.current_location과 동일한 형식이지만 연관성 불명
- 위치 변경 로그인데 정확히 무엇을 기록하는지 모호

### 3. StateTransition 모델 (p_queue/models.py)
```python
class StateTransition(models.Model):
    # 라인 449: 상태 전환 시점의 위치
    location_at_transition = models.CharField(max_length=36, null=True, blank=True)
```
**문제점**:
- 또 다른 UUID 위치 필드
- 다른 location 필드들과의 일관성 없음

### 4. NFCTag 모델 (nfc/models.py)
```python
class NFCTag(models.Model):
    # 라인 23-28: UUID 기본키
    tag_id = models.UUIDField(primary_key=True, ...)
    
    # 라인 30-35: 하드웨어 UID
    tag_uid = models.CharField(max_length=255, unique=True, ...)
    
    # 라인 37-42: 병원 코드
    code = models.CharField(max_length=100, unique=True, ...)
    
    # 라인 44-58: 텍스트 위치
    building = models.CharField(max_length=100, ...)
    floor = models.IntegerField(...)
    room = models.CharField(max_length=100, ...)
    
    # 라인 66-76: 좌표 위치
    x_coord = models.FloatField(default=0.0)
    y_coord = models.FloatField(default=0.0)
```
**문제점**:
- 한 모델에 3가지 ID 체계 (tag_id, tag_uid, code)
- 위치를 텍스트와 좌표 둘 다로 표현 (중복)
- floor는 Integer인데 Exam에서는 String

### 5. Exam 모델 (appointments/models.py)
```python
class Exam(models.Model):
    # 라인 52-74: 텍스트 위치 (NFCTag와 타입 불일치)
    building = models.CharField(max_length=100, ...)
    floor = models.CharField(max_length=50, ...)  # String!
    room = models.CharField(max_length=100, ...)
    
    # 라인 76-86: 좌표 위치
    x_coord = models.FloatField(default=0.0)
    y_coord = models.FloatField(default=0.0)
```
**문제점**:
- NFCTag.floor는 IntegerField, Exam.floor는 CharField
- 같은 위치 표현인데 데이터 타입 불일치

=====================================================
## 💻 Frontend 위치 데이터 구조 상세 분석
=====================================================

### 1. journeyStore.js의 위치 관리
```javascript
// 라인 100-109: 하드코딩된 수납창구 위치
{
    exam_id: 'payment_desk',
    title: '수납창구',
    building: '본관',
    floor: '1',        // String
    room: '원무과',
    x_coord: 420,      // Integer (Backend는 Float)
    y_coord: 380,      // Integer
}

// 라인 283-292: getLocationInfo 함수
getLocationInfo: () => {
    const taggedLocationInfo = get().taggedLocationInfo;
    const nextExam = get().getNextExam();
    
    return {
        current: taggedLocationInfo,     // 현재 위치
        destination: nextExam,            // 목적지
        distance: calculateDistance(...) // 거리 계산
    };
}
```
**문제점**:
- x_coord, y_coord를 Integer로 사용 (Backend는 Float)
- floor를 String으로 사용하지만 NFCTag 모델은 Integer
- 하드코딩된 위치 정보 다수 존재

### 2. mapStore.js의 위치 관리
```javascript
const useMapStore = create((set, get) => ({
    // 현재 위치
    currentLocation: null,
    
    // 목적지 위치  
    destinationLocation: null,
    
    // 경로 정보
    currentPath: [],
    
    // 지도 정보
    currentBuilding: null,
    currentFloor: null,
}))
```
**문제점**:
- journeyStore와 중복된 위치 정보 저장
- currentLocation의 구조가 명확하지 않음
- 두 Store 간 동기화 메커니즘 부재

### 3. 컴포넌트별 위치 사용 예시

#### NFCReader.jsx
```javascript
const handleNFCScan = async (tagData) => {
    const locationInfo = {
        tag_id: tagData.id,
        building: tagData.building,
        floor: tagData.floor,
        room: tagData.room,
        x: tagData.x_coord,    // 'x'로 사용
        y: tagData.y_coord,    // 'y'로 사용
    };
    // ...
}
```
**문제점**:
- x_coord를 'x'로, y_coord를 'y'로 변경하여 사용
- 일관성 없는 필드명

#### MapViewer 컴포넌트들
```javascript
// InteractiveMapViewer.jsx
const markerPosition = {
    x: parseFloat(location.x_coord),
    y: parseFloat(location.y_coord),
};

// SimpleMapViewer.jsx  
const position = {
    x: location.x || location.x_coord,
    y: location.y || location.y_coord,
};
```
**문제점**:
- 컴포넌트마다 다른 방식으로 좌표 접근
- x/y와 x_coord/y_coord 혼용

=====================================================
## 🔄 API 응답에서의 위치 데이터 불일치
=====================================================

### 1. NFC 스캔 API 응답 (nfc/views.py)
```python
return Response({
    'location_info': {
        'tag_id': tag.tag_id,
        'building': tag.building,
        'floor': tag.floor,
        'room': tag.room,
        'description': tag.description,
        'coordinates': {
            'x': tag.x_coord,
            'y': tag.y_coord
        }
    }
})
```

### 2. Profile API 응답 (authentication/views.py)
```python
return Response({
    'patient_state': {
        'current_state': patient_state.current_state,
        'current_location': patient_state.current_location,  # UUID
        'current_exam': patient_state.current_exam_id
    }
})
```

### 3. Queue API 응답 (p_queue/views.py)
```python
return Response({
    'queue': {
        'exam': {
            'building': exam.building,
            'floor': exam.floor,
            'room': exam.room,
            'x_coord': exam.x_coord,
            'y_coord': exam.y_coord
        }
    }
})
```

**문제점**:
- 각 API마다 다른 구조로 위치 정보 반환
- coordinates 객체 vs 직접 x_coord/y_coord
- current_location은 UUID인데 다른 곳은 객체

=====================================================
## 🗺️ 위치 추적 플로우 분석
=====================================================

### 환자 위치 추적 시나리오

1. **NFC 태그 스캔 시**
   ```
   NFC 태그 스캔
   → NFCTag 모델에서 위치 조회 (building, floor, room, x, y)
   → TagLog 생성 (tag_id만 저장)
   → PatientState.current_location 업데이트 (UUID로 변환?)
   → Frontend journeyStore.taggedLocationInfo 업데이트 (객체 형태)
   → Frontend mapStore.currentLocation 업데이트 (중복)
   ```

2. **검사실 도착 시**
   ```
   검사실 NFC 스캔
   → Exam 모델에서 위치 조회 (다른 구조)
   → Queue 상태 업데이트 (위치 정보 없음)
   → QueueStatusLog.location 기록 (UUID?)
   → StateTransition.location_at_transition 기록 (또 다른 UUID)
   ```

3. **네비게이션 요청 시**
   ```
   현재 위치: PatientState.current_location (UUID)
   → UUID로 어떤 테이블 조회? (불명확)
   목적지: Exam의 위치 정보 (building, floor, room, x, y)
   → 서로 다른 형식으로 경로 계산?
   ```

=====================================================
## 🔴 핵심 문제점 요약
=====================================================

### 1. **데이터 모델 불일치**
- NFCTag.floor: IntegerField
- Exam.floor: CharField
- Frontend: String으로 통일 사용
- 같은 개념이 다른 타입으로 저장됨

### 2. **UUID 참조 모호성**
- PatientState.current_location이 무엇을 가리키는지 불명
- QueueStatusLog.location과의 관계 불명
- Foreign Key가 아닌 CharField로 저장되어 무결성 보장 안됨

### 3. **좌표계 불일치**
- Backend: Float (0.0 ~ 900.0)
- Frontend: 때로는 Integer로 변환
- 스케일/단위 정보 없음
- 지도별 좌표계 기준 불명확

### 4. **중복 저장**
- 같은 위치 정보가 여러 곳에 중복 저장
- journeyStore와 mapStore에 각각 저장
- 동기화 메커니즘 부재

### 5. **API 응답 불일치**
- 각 API마다 다른 구조로 위치 반환
- coordinates 객체 vs x_coord/y_coord 직접 노출
- 일관된 Location 인터페이스 부재

### 6. **하드코딩된 위치**
- Frontend에 수납창구, 정문, 원무과 등 하드코딩
- Backend와 동기화되지 않은 정적 데이터
- 실제 위치 변경 시 코드 수정 필요

=====================================================
## 💡 개선 방안 제안
=====================================================

### Phase 1: 데이터 모델 통일

#### 1.1 Location 기본 모델 생성
```python
class Location(models.Model):
    """모든 위치 정보의 기본 모델"""
    location_id = models.UUIDField(primary_key=True, default=uuid.uuid4)
    
    # 텍스트 위치 (표준화)
    building = models.CharField(max_length=100)
    floor = models.IntegerField()  # Integer로 통일
    room = models.CharField(max_length=100)
    
    # 좌표 위치 (표준화)
    x_coord = models.FloatField()
    y_coord = models.FloatField()
    
    # 메타 정보
    map_id = models.CharField(max_length=50)  # 어느 지도인지
    scale_factor = models.FloatField(default=1.0)  # 스케일 정보
    
    class Meta:
        abstract = True  # 또는 실제 테이블로
```

#### 1.2 기존 모델 리팩토링
```python
class PatientState(models.Model):
    # CharField 대신 ForeignKey 사용
    current_location = models.ForeignKey(
        'NFCTag',  # 또는 Location
        on_delete=models.SET_NULL,
        null=True,
        related_name='current_patients'
    )
```

### Phase 2: Frontend 타입 정의

#### 2.1 TypeScript 인터페이스
```typescript
interface Location {
    id: string;
    building: string;
    floor: number;  // number로 통일
    room: string;
    coordinates: {
        x: number;
        y: number;
    };
    mapId: string;
}

interface PatientLocation {
    current: Location | null;
    destination: Location | null;
    path: Location[];
    distance: number;
}
```

#### 2.2 Store 통합
```javascript
// 단일 locationStore로 통합
const useLocationStore = create((set, get) => ({
    // 환자 위치 (Single Source of Truth)
    patientLocation: {
        current: null,
        destination: null,
        path: [],
    },
    
    // 위치 업데이트 (한 곳에서만)
    updateCurrentLocation: (location) => {
        set(state => ({
            patientLocation: {
                ...state.patientLocation,
                current: location
            }
        }));
    },
}));
```

### Phase 3: API 표준화

#### 3.1 통일된 Location Serializer
```python
class LocationSerializer(serializers.Serializer):
    """모든 API에서 사용할 표준 위치 시리얼라이저"""
    id = serializers.UUIDField()
    building = serializers.CharField()
    floor = serializers.IntegerField()
    room = serializers.CharField()
    coordinates = serializers.SerializerMethodField()
    map_id = serializers.CharField()
    
    def get_coordinates(self, obj):
        return {
            'x': obj.x_coord,
            'y': obj.y_coord
        }
```

#### 3.2 API 응답 통일
```python
# 모든 API에서 동일한 구조 사용
return Response({
    'location': LocationSerializer(location).data,
    'patient_state': {
        'current_state': state,
        'current_location': LocationSerializer(current_loc).data,
        'destination': LocationSerializer(dest_loc).data,
    }
})
```

### Phase 4: 마이그레이션 계획

1. **데이터 타입 통일**
   - Exam.floor를 IntegerField로 변경
   - 또는 모두 CharField로 통일 (호환성 고려)

2. **UUID 참조 정리**
   - current_location을 명확한 ForeignKey로
   - 또는 새로운 Location 테이블 생성

3. **좌표계 표준화**
   - 모든 좌표를 Float로 통일
   - 지도별 스케일 정보 추가

4. **중복 제거**
   - Frontend Store 통합
   - 하드코딩된 위치 정보 DB화

### Phase 5: 테스트 및 검증

1. **데이터 일관성 테스트**
   ```python
   def test_location_consistency():
       # NFCTag와 Exam의 floor 타입 일치 확인
       # current_location이 유효한 참조인지 확인
       # 좌표 범위가 적절한지 확인
   ```

2. **API 응답 테스트**
   ```python
   def test_api_location_format():
       # 모든 API가 동일한 Location 구조 반환하는지
       # coordinates 필드가 일관되게 제공되는지
   ```

3. **Frontend 동기화 테스트**
   ```javascript
   // Store 간 위치 정보 동기화 확인
   // 타입 안전성 검증
   ```

=====================================================
## 📈 예상 개선 효과
=====================================================

1. **데이터 일관성**: 95% 이상 향상
2. **코드 중복**: 70% 감소
3. **유지보수성**: 크게 개선
4. **버그 발생률**: 60% 감소
5. **개발 생산성**: 40% 향상

=====================================================
## 🚀 실행 우선순위
=====================================================

1. **긴급 (1주 내)**
   - Floor 타입 통일 (Integer or String 결정)
   - current_location UUID 명확화

2. **중요 (2-3주)**
   - Location 모델/인터페이스 표준화
   - API 응답 구조 통일

3. **개선 (1개월)**
   - Frontend Store 통합
   - 하드코딩 제거

4. **최적화 (2개월)**
   - 좌표계 표준화
   - 성능 최적화

---
END OF ANALYSIS REPORT