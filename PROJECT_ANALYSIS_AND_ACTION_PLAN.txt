==============================================================================
NFC 병원 안내 시스템 - 실제 코드 분석 및 문제점 정리
==============================================================================
분석일: 2025-09-09
분석자: Claude Code
교수님 피드백 반영: 2025-09-09 면담 내용 기반

==============================================================================
1. 실제 코드 분석 결과 - 구체적인 문제점
==============================================================================

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🔴 핵심 문제 1: 상태 관리의 이원화 (가장 심각)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[현재 상황]
- 2개의 상태 체계가 분리 운영되고 있음:
  * PatientJourneyState: 9단계 환자 전체 여정 (UNREGISTERED ~ FINISHED)
  * QueueDetailState: 7단계 대기열 세부 상태 (waiting ~ cancelled)

[구체적 코드 증거]
파일: backend/nfc_hospital_system/common/state_definitions.py
```python
class PatientJourneyState(Enum):
    UNREGISTERED = 'UNREGISTERED'
    ARRIVED = 'ARRIVED'
    REGISTERED = 'REGISTERED'
    WAITING = 'WAITING'
    CALLED = 'CALLED'
    IN_PROGRESS = 'IN_PROGRESS'
    COMPLETED = 'COMPLETED'
    PAYMENT = 'PAYMENT'
    FINISHED = 'FINISHED'

class QueueDetailState(Enum):
    WAITING = 'waiting'
    DELAYED = 'delayed'
    CALLED = 'called'
    NO_SHOW = 'no_show'
    IN_PROGRESS = 'in_progress'
    COMPLETED = 'completed'
    CANCELLED = 'cancelled'
```

[동기화 문제]
파일: backend/nfc_hospital_system/p_queue/services.py
```python
def sync_from_queue_update(self, queue: Queue):
    # Queue → PatientState 동기화
    journey_state = QUEUE_TO_JOURNEY_MAPPING.get(queue_state)
    
def sync_from_patient_state(self, patient_state: PatientState):
    # PatientState → Queue 동기화
    queue_state = JOURNEY_TO_QUEUE_MAPPING.get(journey_state)
```

[문제점]
1. 양방향 동기화로 인한 순환 참조 위험
2. 어느 것이 진실의 원천(Single Source of Truth)인지 불명확
3. 상태 변경 시 2곳을 모두 업데이트해야 함
4. 매핑 로직이 복잡하고 오류 발생 가능성 높음

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🔴 핵심 문제 2: 데이터베이스 연동 실패 (교수님 지적사항)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[현재 상황]
- 가상 데이터와 화면 페이지 간의 데이터 동기화 안 됨
- 각 모듈이 독립적으로 작동하여 통합 안 됨

[구체적 코드 증거]
파일: frontend-pwa/src/components/admin/dashboard/OperationalMonitor.jsx
```javascript
useEffect(() => {
    const updateData = () => {
      const deptData = [
        { 
          waitingPatients: Math.floor(15 + Math.random() * 20),  // 랜덤 데이터
          avgWaitTime: Math.floor(25 + Math.random() * 15),      // 랜덤 데이터
        }
      ];
      setDepartments(deptData);
    };
    updateData();
    const interval = setInterval(updateData, 15000);
}, []);
```

파일: frontend-pwa/src/components/admin/dashboard/LSTMPrediction.jsx
```javascript
// 실제 LSTM 모델 없이 프론트엔드에서 시뮬레이션
const waitTime = Math.round(
    dept.baseline + (dept.peak - dept.baseline) * peakFactor * 0.7 + randomVariation
);
```

[문제점]
1. 실제 Queue 데이터와 연결되지 않음
2. Analytics API는 구현되어 있으나 사용하지 않음
3. WebSocket은 대기열 상태만 전송, 대시보드는 미연동
4. 프론트엔드에서 가짜 데이터 생성

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🔴 핵심 문제 3: 진료 vs 검사 구분 없음
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[현재 상황]
- Appointment 모델에 진료/검사 구분 없음
- Exam 모델만 존재 (Doctor 모델 없음)
- 의사별 대기 시간 고려 안 됨

[구체적 코드 증거]
파일: backend/nfc_hospital_system/appointments/models.py
```python
class Appointment(models.Model):
    exam = models.ForeignKey('Exam', ...)  # 검사만 참조
    # doctor 필드 없음
    # appointment_type 필드 없음
    # consultation 관련 필드 전무
```

[문제점]
1. 진료 프로세스 전체 누락
2. 의사별 스케줄 관리 불가
3. 진료실 대기와 검사실 대기 구분 불가
4. 현대병원 피드백: "검사 위주로만 되어 있음"

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🔴 핵심 문제 4: 프론트엔드의 하드코딩된 비즈니스 로직
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[현재 상황]
- 비즈니스 로직이 백엔드가 아닌 프론트엔드에 하드코딩

[구체적 코드 증거]
파일: frontend-pwa/src/store/journeyStore.js
```javascript
getNextExam: () => {
  if (patientState === 'PAYMENT') {
    return {
      exam_id: 'payment_desk',
      title: '수납창구',
      building: '본관',
      floor: '1',
      room: '원무과',
      x_coord: 420,  // 하드코딩된 좌표
      y_coord: 380,  // 하드코딩된 좌표
      description: '수납창구에서 진료비를 수납해주세요'
    };
  }
  
  if (patientState === 'FINISHED') {
    return {
      exam_id: 'main_entrance',
      title: '정문',
      x_coord: 150,  // 하드코딩된 좌표
      y_coord: 400,  // 하드코딩된 좌표
    };
  }
}
```

[문제점]
1. 병원 레이아웃 변경 시 프론트엔드 수정 필요
2. 비즈니스 로직이 클라이언트에 노출
3. 백엔드와 프론트엔드 로직 불일치 가능
4. 테스트 및 유지보수 어려움

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🔴 핵심 문제 5: WebSocket과 HTTP API 중복 구현
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[현재 상황]
- 같은 기능을 WebSocket과 HTTP 2가지로 구현

[구체적 코드 증거]
파일: frontend-pwa/src/hooks/usePatientJourney.js
```javascript
const performAction = useCallback(async (actionType, payload = {}) => {
    // WebSocket이 연결되어 있으면 WebSocket 사용
    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
      wsRef.current.send(JSON.stringify({
        command: 'perform_action',
        action_type: actionType,
        payload
      }));
      return;
    }
    
    // WebSocket이 연결되지 않은 경우 HTTP 폴백
    try {
      const data = await PatientJourneyAPI.performAction(actionType, payload);
      updateState(data);
      return data;
    } catch (error) {
      // ...
    }
}, []);
```

[문제점]
1. 코드 중복으로 유지보수 어려움
2. 동기화 문제 발생 가능
3. 디버깅 복잡도 증가
4. 일관성 없는 응답 형식 가능

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🔴 핵심 문제 6: AI 기능 부재 (교수님 지적사항)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[현재 상황]
- LSTM 모델 백엔드 구현 없음
- 프론트엔드 시뮬레이션만 존재
- "AI 기반" 시스템이라는 정체성 부족

[구체적 증거]
```bash
$ grep -r "LSTM" backend/
# No results (백엔드에 LSTM 구현 없음)

$ grep -r "tensorflow\|pytorch\|scikit" backend/requirements.txt
# No results (ML 라이브러리 없음)
```

[문제점]
1. 실제 예측 기능 없음
2. 과거 데이터 학습 불가
3. 정확도 개선 불가능
4. AI 시스템이라 할 수 없음

==============================================================================
2. 개념적으로 정리해야 할 사항
==============================================================================

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
개념 1: 상태 관리 단일화 (Single Source of Truth)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[현재]
PatientJourneyState (9단계) + QueueDetailState (7단계) = 복잡한 매핑

[제안] UnifiedPatientState (5단계)
```
ARRIVED      → 병원 도착/접수
WAITING      → 대기 중
IN_PROGRESS  → 진행 중 (진료/검사)
PAYMENT      → 수납
COMPLETED    → 완료/귀가
```

[구현 방안]
```python
class UnifiedPatientState(models.Model):
    state = models.CharField(choices=UNIFIED_STATES)
    queue = models.OneToOneField(Queue, null=True)
    
    def transition_to(self, new_state):
        # 단일 지점에서 모든 상태 변경 처리
        self.state = new_state
        self.save()
        self.sync_related_models()
        self.broadcast_update()
```

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
개념 2: 진료/검사 통합 모델
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[제안 모델]
```python
class AppointmentType(Enum):
    CONSULTATION = "consultation"  # 진료
    EXAMINATION = "examination"    # 검사

class Appointment(models.Model):
    appointment_type = models.CharField(choices=AppointmentType.choices)
    doctor = models.ForeignKey('Doctor', null=True)  # 진료일 때
    exam = models.ForeignKey('Exam', null=True)      # 검사일 때
    
    def get_destination(self):
        if self.appointment_type == AppointmentType.CONSULTATION:
            return self.doctor.office_location
        else:
            return self.exam.location
```

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
개념 3: 호출 함수 방식의 서비스 레이어 (교수님 제안)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[제안 구조]
```python
class UnifiedJourneyService:
    """모든 상태 변경의 단일 진입점"""
    
    @transaction.atomic
    def update_patient_state(self, patient_id, new_state, trigger):
        # 1단계: 상태 검증
        if not self.is_valid_transition(current_state, new_state):
            raise InvalidTransition()
        
        # 2단계: PatientState 업데이트
        patient_state = PatientState.objects.get(user_id=patient_id)
        patient_state.current_state = new_state
        patient_state.save()
        
        # 3단계: Queue 자동 동기화
        if new_state in QUEUE_RELATED_STATES:
            self.sync_queue_state(patient_id, new_state)
        
        # 4단계: WebSocket 브로드캐스트
        self.broadcast_state_change(patient_id, new_state)
        
        # 5단계: 로그 기록
        self.log_state_transition(patient_id, old_state, new_state, trigger)
        
        # 6단계: 통합 응답 반환
        return self.get_unified_response(patient_id)
```

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
개념 4: 실시간 데이터 파이프라인
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[제안 아키텍처]
```
Queue Model (실제 데이터)
    ↓
Analytics Service (집계/계산)
    ↓
Redis Cache (실시간 캐싱)
    ↓
    ├→ REST API → Dashboard (초기 로드)
    └→ WebSocket → Real-time Updates
```

[구현 예시]
```python
class RealtimeAnalyticsService:
    def get_department_stats(self, department):
        # 1. Redis에서 캐시 확인
        cached = redis.get(f"dept_stats:{department}")
        if cached:
            return cached
        
        # 2. 실제 데이터 집계
        stats = Queue.objects.filter(
            exam__department=department,
            state='waiting'
        ).aggregate(
            waiting_count=Count('id'),
            avg_wait_time=Avg('estimated_wait_time')
        )
        
        # 3. Redis에 캐시 (TTL 5초)
        redis.setex(f"dept_stats:{department}", 5, stats)
        
        # 4. WebSocket으로 브로드캐스트
        channel_layer.group_send(
            f"dashboard_{department}",
            {"type": "stats_update", "data": stats}
        )
        
        return stats
```

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
개념 5: LSTM 점진적 구현 전략
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[3단계 접근법]
```python
# Phase 1: Baseline Model (즉시 구현 가능)
class BaselinePredictor:
    def predict(self, department, hour):
        # 지난 7일 같은 시간대 평균
        return historical_average

# Phase 2: Simple LSTM (1주일)
class SimpleLSTM:
    def __init__(self):
        self.model = Sequential([
            LSTM(32, input_shape=(24, 5)),
            Dense(1)
        ])

# Phase 3: Advanced LSTM (2주일)
class AdvancedLSTM:
    # 부서별 특화 모델
    # 요일/공휴일 고려
    # 실시간 재학습
```

==============================================================================
3. 실행 계획 (우선순위별)
==============================================================================

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Phase 0: 긴급 수정 (3일 내) - "기능 구현 후 세부사항"
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[Day 1] DB 연동 문제 해결
□ UnifiedJourneyService 구현
□ 호출 함수 방식으로 모듈 순차 실행
□ WebSocket 이벤트 통합

[Day 2] 상태 단순화
□ 9단계 → 5단계로 축소
□ 마이그레이션 스크립트 작성
□ Feature Flag 설정

[Day 3] 실제 데이터 연결
□ Dashboard API 실제 구현
□ Queue 데이터 집계 로직
□ Redis 캐싱 설정

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Phase 1: LSTM 구현 (1주일) - "AI 정체성 강화"
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[Day 4-5] 데이터 수집
□ QueueDataCollector 구현
□ 시드 데이터 1000+ 생성
□ 학습 데이터 준비

[Day 6-7] Baseline 모델
□ 이동평균 예측 구현
□ API 엔드포인트 생성
□ 70% 정확도 달성

[Day 8-10] LSTM 모델
□ TensorFlow 모델 구현
□ 학습 파이프라인
□ 점진적 개선 시각화

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Phase 2: 진료 기능 (선택적, 5일) - "진료 vs 검사 구분"
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[Day 11-12] 모델 확장
□ Doctor 모델 추가
□ AppointmentType 구현
□ 진료실 대기 로직

[Day 13-15] UI 통합
□ 진료/검사 구분 UI
□ 의사별 대기 표시
□ 통합 테스트

==============================================================================
4. 성공 지표 (교수님 제시 기준)
==============================================================================

단기 목표 (1주일)
─────────────────
✓ DB 연동 100% 작동
✓ 상태 5단계로 단순화
✓ 대시보드 실제 데이터 표시

중기 목표 (2주일)
─────────────────
✓ LSTM 예측 정확도 80%+
✓ 주간 2% 개선 증명
✓ 실시간 업데이트 작동

최종 목표 (10월 중순)
─────────────────
✓ LSTM 오차율 2-3%
✓ 진료/검사 통합 완료
✓ 현대병원 피드백 반영

==============================================================================
5. 리스크 및 대응 방안
==============================================================================

리스크 1: 상태 마이그레이션 실패
─────────────────────────────
- 영향: 기존 데이터 손실
- 대응: 백업 + 롤백 스크립트 준비

리스크 2: LSTM 정확도 미달
─────────────────────────
- 영향: AI 기능 신뢰도 하락
- 대응: Baseline 모델 유지, 점진적 개선

리스크 3: 진료 기능 복잡도
─────────────────────
- 영향: 개발 지연
- 대응: 검사 우선 완성, 진료는 v2

==============================================================================
6. 즉시 결정 필요 사항
==============================================================================

1. 상태 단순화 수준
   □ Option A: 5단계 (추천)
   □ Option B: 7단계
   □ Option C: 현행 유지

2. LSTM 구현 범위
   □ Option A: 1개 부서 시작 (추천)
   □ Option B: 전체 부서
   □ Option C: 시뮬레이션 유지

3. 진료 기능 포함 여부
   □ Option A: 검사만 집중 (추천)
   □ Option B: 진료 추가
   □ Option C: 추후 결정

==============================================================================
끝
==============================================================================

본 문서는 2025년 9월 9일 교수님 면담 내용을 바탕으로
실제 코드를 분석하여 구체적인 문제점과 해결 방안을 정리한 것입니다.

핵심 메시지:
"기능 구현 후 세부사항 추가" - 교수님
"호출 함수로 순차 실행" - 교수님
"주간 2% 개선 증명" - 교수님

문서 버전: 1.0.0
마지막 수정: 2025-09-09