# í™˜ì ìƒíƒœ/í ìƒíƒœ ë¦¬íŒ©í† ë§ ê³„íšì„œ (ê°œì„ íŒ v2)
ìƒì„±ì¼: 2025-01-03
ì‘ì„±ì: Claude
ë²„ì „: 2.0

## ğŸ¯ í•µì‹¬ ê°œì„  ì „ëµ

### 1. Single Source of Truth (SSOT) ì›ì¹™
- **ëª¨ë“  ìƒíƒœ ì •ì˜ì™€ ë§¤í•‘ ê·œì¹™ì€ Backendì—ì„œë§Œ ê´€ë¦¬**
- FrontendëŠ” Backend APIë¥¼ í†µí•´ ìƒíƒœ ì •ë³´ë¥¼ ë°›ì•„ ì‚¬ìš©
- ìƒíƒœ ë³€í™˜ ë¡œì§ ì¤‘ë³µ ì œê±°

### 2. Event-Driven Architecture
- ClientëŠ” ìƒíƒœë¥¼ ì§ì ‘ ë³€ê²½í•˜ì§€ ì•Šê³  ì•¡ì…˜/ì´ë²¤íŠ¸ë§Œ ì „ì†¡
- Serverê°€ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì— ë”°ë¼ ìƒíƒœ ì „ì´ ê²°ì •
- ìƒíƒœ ì „ì´ ê·œì¹™ì˜ ì¤‘ì•™í™”

### 3. Service Layer Pattern
- ìƒíƒœ ê´€ë¦¬ ë¡œì§ì„ ì„œë¹„ìŠ¤ ê³„ì¸µìœ¼ë¡œ ìº¡ìŠí™”
- í…ŒìŠ¤íŠ¸ ê°€ëŠ¥ì„±ê³¼ ì¬ì‚¬ìš©ì„± í–¥ìƒ
- Signalê³¼ Viewì˜ ì±…ì„ ë¶„ë¦¬

=====================================================
## ğŸ“Š í˜„í™© ë¶„ì„ (ê¸°ì¡´ ê³„íšì„œ ì°¸ì¡°)
=====================================================

### í˜„ì¬ ì‹œìŠ¤í…œì˜ 3ì¤‘ êµ¬ì¡°
1. **PatientState.current_state** (9ë‹¨ê³„ í™˜ì ì—¬ì •)
2. **Queue.state** (7ë‹¨ê³„ ëŒ€ê¸°ì—´ ìƒíƒœ)  
3. **Appointment.status** (4+Î± ì˜ˆì•½ ìƒíƒœ)

### ì£¼ìš” ë¬¸ì œì 
- ìƒíƒœ ëª¨ë¸ ë¶ˆì¼ì¹˜ (ongoing vs in_progress)
- ë§¤í•‘ ë¡œì§ ì‚°ì¬ (Frontend/Backend ì¤‘ë³µ)
- API ì—”ë“œí¬ì¸íŠ¸ í˜¼ì¬ (5ê°œ ì´ìƒ)
- ë™ê¸°í™” ë©”ì»¤ë‹ˆì¦˜ ë¶€ì¬
- ì½”ë“œ ì¤‘ë³µ (20ê°œ+ ì»´í¬ë„ŒíŠ¸)

=====================================================
## ğŸ—ï¸ Phase 1: ìƒíƒœ ëª¨ë¸ ì •ì˜ (Backend ì¤‘ì‹¬í™”)
=====================================================

### 1.1 í†µí•© ìƒíƒœ ì •ì˜ (Backend Only)
```python
# common/state_definitions.py (ìƒˆ íŒŒì¼)
from enum import Enum
from typing import Dict, List, Optional

class PatientJourneyState(Enum):
    """í™˜ì ì „ì²´ ì—¬ì • ìƒíƒœ (ìµœìƒìœ„)"""
    UNREGISTERED = 'UNREGISTERED'
    ARRIVED = 'ARRIVED'
    REGISTERED = 'REGISTERED'
    WAITING = 'WAITING'
    CALLED = 'CALLED'
    IN_PROGRESS = 'IN_PROGRESS'  # ONGOING ëŒ€ì‹  í†µì¼
    COMPLETED = 'COMPLETED'
    PAYMENT = 'PAYMENT'
    FINISHED = 'FINISHED'

class QueueDetailState(Enum):
    """ëŒ€ê¸°ì—´ ì„¸ë¶€ ìƒíƒœ"""
    WAITING = 'waiting'
    DELAYED = 'delayed'
    CALLED = 'called'
    NO_SHOW = 'no_show'
    IN_PROGRESS = 'in_progress'  # ongoing ëŒ€ì‹  í†µì¼
    COMPLETED = 'completed'
    CANCELLED = 'cancelled'

class PatientAction(Enum):
    """í™˜ìê°€ ìˆ˜í–‰í•  ìˆ˜ ìˆëŠ” ì•¡ì…˜"""
    SCAN_NFC = 'scan_nfc'
    REGISTER = 'register'
    CONFIRM_ARRIVAL = 'confirm_arrival'
    ENTER_EXAM_ROOM = 'enter_exam_room'
    COMPLETE_EXAM = 'complete_exam'
    MAKE_PAYMENT = 'make_payment'
    LEAVE_HOSPITAL = 'leave_hospital'

class StaffAction(Enum):
    """ì˜ë£Œì§„ì´ ìˆ˜í–‰í•  ìˆ˜ ìˆëŠ” ì•¡ì…˜"""
    CALL_PATIENT = 'call_patient'
    START_EXAM = 'start_exam'
    COMPLETE_EXAM = 'complete_exam'
    MARK_NO_SHOW = 'mark_no_show'
    CANCEL_APPOINTMENT = 'cancel_appointment'

# ìƒíƒœ ì „ì´ ê·œì¹™ ì •ì˜
STATE_TRANSITIONS = {
    PatientJourneyState.UNREGISTERED: {
        PatientAction.SCAN_NFC: PatientJourneyState.ARRIVED,
    },
    PatientJourneyState.ARRIVED: {
        PatientAction.REGISTER: PatientJourneyState.REGISTERED,
    },
    PatientJourneyState.REGISTERED: {
        PatientAction.CONFIRM_ARRIVAL: PatientJourneyState.WAITING,
    },
    PatientJourneyState.WAITING: {
        StaffAction.CALL_PATIENT: PatientJourneyState.CALLED,
        StaffAction.MARK_NO_SHOW: PatientJourneyState.WAITING,  # ìƒíƒœ ìœ ì§€
    },
    PatientJourneyState.CALLED: {
        PatientAction.ENTER_EXAM_ROOM: PatientJourneyState.IN_PROGRESS,
        StaffAction.START_EXAM: PatientJourneyState.IN_PROGRESS,
        StaffAction.MARK_NO_SHOW: PatientJourneyState.WAITING,  # ë‹¤ì‹œ ëŒ€ê¸°
    },
    PatientJourneyState.IN_PROGRESS: {
        PatientAction.COMPLETE_EXAM: PatientJourneyState.COMPLETED,
        StaffAction.COMPLETE_EXAM: PatientJourneyState.COMPLETED,
    },
    PatientJourneyState.COMPLETED: {
        PatientAction.CONFIRM_ARRIVAL: PatientJourneyState.WAITING,  # ë‹¤ìŒ ê²€ì‚¬
        PatientAction.MAKE_PAYMENT: PatientJourneyState.PAYMENT,
    },
    PatientJourneyState.PAYMENT: {
        PatientAction.MAKE_PAYMENT: PatientJourneyState.FINISHED,
    },
    PatientJourneyState.FINISHED: {
        PatientAction.LEAVE_HOSPITAL: PatientJourneyState.UNREGISTERED,
    },
}

# Queue ìƒíƒœì™€ Journey ìƒíƒœ ë§¤í•‘
QUEUE_TO_JOURNEY_MAPPING = {
    QueueDetailState.WAITING: PatientJourneyState.WAITING,
    QueueDetailState.DELAYED: PatientJourneyState.WAITING,
    QueueDetailState.CALLED: PatientJourneyState.CALLED,
    QueueDetailState.NO_SHOW: PatientJourneyState.WAITING,
    QueueDetailState.IN_PROGRESS: PatientJourneyState.IN_PROGRESS,
    QueueDetailState.COMPLETED: PatientJourneyState.COMPLETED,
    QueueDetailState.CANCELLED: PatientJourneyState.COMPLETED,
}

# Journey ìƒíƒœì™€ Queue ìƒíƒœ ì—­ë§¤í•‘
JOURNEY_TO_QUEUE_MAPPING = {
    PatientJourneyState.WAITING: QueueDetailState.WAITING,
    PatientJourneyState.CALLED: QueueDetailState.CALLED,
    PatientJourneyState.IN_PROGRESS: QueueDetailState.IN_PROGRESS,
    PatientJourneyState.COMPLETED: QueueDetailState.COMPLETED,
}
```

### 1.2 ìƒíƒœ ì •ì˜ API ì—”ë“œí¬ì¸íŠ¸
```python
# common/views.py (ìƒˆ íŒŒì¼)
from rest_framework.views import APIView
from rest_framework.response import Response
from .state_definitions import *

class StateDefinitionsView(APIView):
    """Frontendì—ì„œ ìƒíƒœ ì •ì˜ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ìˆëŠ” API"""
    authentication_classes = []  # ê³µê°œ API
    permission_classes = []
    
    def get(self, request):
        return Response({
            'journey_states': [state.value for state in PatientJourneyState],
            'queue_states': [state.value for state in QueueDetailState],
            'patient_actions': [action.value for action in PatientAction],
            'staff_actions': [action.value for action in StaffAction],
            'state_transitions': self._serialize_transitions(),
            'mappings': {
                'queue_to_journey': {k.value: v.value for k, v in QUEUE_TO_JOURNEY_MAPPING.items()},
                'journey_to_queue': {k.value: v.value for k, v in JOURNEY_TO_QUEUE_MAPPING.items()},
            }
        })
    
    def _serialize_transitions(self):
        result = {}
        for state, transitions in STATE_TRANSITIONS.items():
            result[state.value] = {
                action.value: next_state.value 
                for action, next_state in transitions.items()
            }
        return result
```

### 1.3 Frontend íƒ€ì… ì •ì˜ (Backend ì˜ì¡´ì )
```typescript
// types/states.ts (ê°„ì†Œí™”)
// Backend APIì—ì„œ ê°€ì ¸ì˜¨ ì •ì˜ë¥¼ ì‚¬ìš©

export interface StateDefinitions {
    journey_states: string[];
    queue_states: string[];
    patient_actions: string[];
    staff_actions: string[];
    state_transitions: Record<string, Record<string, string>>;
    mappings: {
        queue_to_journey: Record<string, string>;
        journey_to_queue: Record<string, string>;
    };
}

// ì•± ì‹œì‘ ì‹œ Backendì—ì„œ ìƒíƒœ ì •ì˜ë¥¼ ê°€ì ¸ì˜´
export let stateDefinitions: StateDefinitions;

export const loadStateDefinitions = async () => {
    const response = await fetch('/api/v1/state-definitions/');
    stateDefinitions = await response.json();
};

// ë§¤í•‘ í•¨ìˆ˜ëŠ” Backend ë°ì´í„° ì‚¬ìš©
export const mapQueueToJourney = (queueState: string): string => {
    return stateDefinitions.mappings.queue_to_journey[queueState];
};
```

=====================================================
## ğŸ® Phase 2: Service Layer ë„ì…
=====================================================

### 2.1 PatientJourneyService í´ë˜ìŠ¤
```python
# p_queue/services.py (ìƒˆ íŒŒì¼)
from typing import Optional, Dict, Any
from django.db import transaction
from django.core.exceptions import ValidationError
from channels.layers import get_channel_layer
from asgiref.sync import async_to_sync

from .models import PatientState, Queue, StateTransition, QueueStatusLog
from common.state_definitions import *
from appointments.models import Appointment

class InvalidActionError(Exception):
    """ì˜ëª»ëœ ì•¡ì…˜ ìš”ì²­"""
    pass

class PatientJourneyService:
    """í™˜ì ì—¬ì • ìƒíƒœ ê´€ë¦¬ ì„œë¹„ìŠ¤"""
    
    def __init__(self, user):
        self.user = user
        self.channel_layer = get_channel_layer()
        
    @transaction.atomic
    def perform_action(self, action_type: str, payload: Dict[str, Any] = None) -> Dict[str, Any]:
        """
        ì•¡ì…˜ì„ ìˆ˜í–‰í•˜ê³  ìƒíƒœë¥¼ ì „ì´ì‹œí‚´
        
        Args:
            action_type: ìˆ˜í–‰í•  ì•¡ì…˜ íƒ€ì…
            payload: ì•¡ì…˜ì— í•„ìš”í•œ ì¶”ê°€ ë°ì´í„°
            
        Returns:
            ë³€ê²½ëœ ìƒíƒœ ì •ë³´
            
        Raises:
            InvalidActionError: ì˜ëª»ëœ ì•¡ì…˜ì´ë‚˜ ì „ì´ ë¶ˆê°€ëŠ¥í•œ ê²½ìš°
        """
        # í˜„ì¬ ìƒíƒœ ì¡°íšŒ
        patient_state = self._get_or_create_patient_state()
        current_state = PatientJourneyState(patient_state.current_state)
        
        # ì•¡ì…˜ íƒ€ì… í™•ì¸
        try:
            if action_type in [a.value for a in PatientAction]:
                action = PatientAction(action_type)
            elif action_type in [a.value for a in StaffAction]:
                action = StaffAction(action_type)
            else:
                raise InvalidActionError(f"Unknown action type: {action_type}")
        except ValueError:
            raise InvalidActionError(f"Invalid action: {action_type}")
        
        # ìƒíƒœ ì „ì´ ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸
        if current_state not in STATE_TRANSITIONS:
            raise InvalidActionError(f"No transitions defined for state: {current_state.value}")
            
        transitions = STATE_TRANSITIONS[current_state]
        if action not in transitions:
            raise InvalidActionError(
                f"Action '{action_type}' is not allowed in state '{current_state.value}'"
            )
        
        # ìƒˆë¡œìš´ ìƒíƒœ
        new_state = transitions[action]
        
        # ìƒíƒœ ë³€ê²½ ìˆ˜í–‰
        old_state_value = patient_state.current_state
        patient_state.current_state = new_state.value
        patient_state.save()
        
        # Queue ìƒíƒœ ë™ê¸°í™” (í•„ìš”í•œ ê²½ìš°)
        self._sync_queue_state(new_state, payload)
        
        # ìƒíƒœ ì „í™˜ ë¡œê·¸ ìƒì„±
        StateTransition.objects.create(
            user=self.user,
            from_state=old_state_value,
            to_state=new_state.value,
            trigger_type=self._get_trigger_type(action),
            trigger_source=action_type,
            metadata=payload
        )
        
        # WebSocket ì•Œë¦¼ ì „ì†¡
        self._send_state_update(new_state.value, action_type)
        
        # ì‘ë‹µ ë°ì´í„° êµ¬ì„±
        return self._build_response(patient_state)
    
    def get_current_state(self) -> Dict[str, Any]:
        """í˜„ì¬ í™˜ì ìƒíƒœ ì¡°íšŒ"""
        patient_state = self._get_or_create_patient_state()
        return self._build_response(patient_state)
    
    @transaction.atomic
    def sync_from_queue_update(self, queue: Queue):
        """Queue ìƒíƒœ ë³€ê²½ì— ë”°ë¥¸ PatientState ë™ê¸°í™”"""
        try:
            queue_state = QueueDetailState(queue.state)
            journey_state = QUEUE_TO_JOURNEY_MAPPING.get(queue_state)
            
            if journey_state:
                patient_state = self._get_or_create_patient_state()
                if patient_state.current_state != journey_state.value:
                    old_state = patient_state.current_state
                    patient_state.current_state = journey_state.value
                    patient_state.save()
                    
                    # ìƒíƒœ ì „í™˜ ë¡œê·¸
                    StateTransition.objects.create(
                        user=self.user,
                        from_state=old_state,
                        to_state=journey_state.value,
                        trigger_type='queue_sync',
                        trigger_source=f"Queue state changed to {queue.state}"
                    )
                    
                    # WebSocket ì•Œë¦¼
                    self._send_state_update(journey_state.value, 'queue_sync')
        except ValueError:
            # ì•Œ ìˆ˜ ì—†ëŠ” queue stateëŠ” ë¬´ì‹œ
            pass
    
    @transaction.atomic
    def sync_from_patient_state(self, patient_state: PatientState):
        """PatientState ë³€ê²½ì— ë”°ë¥¸ Queue ë™ê¸°í™”"""
        try:
            journey_state = PatientJourneyState(patient_state.current_state)
            queue_state = JOURNEY_TO_QUEUE_MAPPING.get(journey_state)
            
            if queue_state:
                # í™œì„± í ì¡°íšŒ
                active_queue = Queue.objects.filter(
                    user=self.user,
                    state__in=[QueueDetailState.WAITING.value, 
                               QueueDetailState.CALLED.value,
                               QueueDetailState.IN_PROGRESS.value]
                ).first()
                
                if active_queue and active_queue.state != queue_state.value:
                    old_state = active_queue.state
                    active_queue.state = queue_state.value
                    active_queue.save()
                    
                    # Queue ìƒíƒœ ë³€ê²½ ë¡œê·¸
                    QueueStatusLog.objects.create(
                        queue=active_queue,
                        previous_state=old_state,
                        new_state=queue_state.value,
                        reason="Synced from PatientState",
                        changed_by=None  # System
                    )
        except ValueError:
            pass
    
    def _get_or_create_patient_state(self) -> PatientState:
        """í™˜ì ìƒíƒœ ì¡°íšŒ ë˜ëŠ” ìƒì„±"""
        patient_state, created = PatientState.objects.get_or_create(
            user=self.user,
            defaults={
                'current_state': PatientJourneyState.UNREGISTERED.value,
                'is_logged_in': True,
                'login_method': 'simple'
            }
        )
        return patient_state
    
    def _sync_queue_state(self, new_journey_state: PatientJourneyState, payload: Dict[str, Any]):
        """Journey ìƒíƒœì— ë”°ë¥¸ Queue ìƒíƒœ ë™ê¸°í™”"""
        queue_state = JOURNEY_TO_QUEUE_MAPPING.get(new_journey_state)
        
        if queue_state:
            # í™œì„± íê°€ ìˆëŠ”ì§€ í™•ì¸
            active_queue = Queue.objects.filter(
                user=self.user,
                state__in=[QueueDetailState.WAITING.value, 
                          QueueDetailState.CALLED.value,
                          QueueDetailState.IN_PROGRESS.value]
            ).first()
            
            if active_queue:
                old_state = active_queue.state
                active_queue.state = queue_state.value
                active_queue.save()
                
                QueueStatusLog.objects.create(
                    queue=active_queue,
                    previous_state=old_state,
                    new_state=queue_state.value,
                    reason=f"Journey state changed to {new_journey_state.value}",
                    changed_by=None,
                    metadata=payload
                )
    
    def _get_trigger_type(self, action) -> str:
        """ì•¡ì…˜ìœ¼ë¡œë¶€í„° íŠ¸ë¦¬ê±° íƒ€ì… ê²°ì •"""
        if isinstance(action, PatientAction):
            if action == PatientAction.SCAN_NFC:
                return 'nfc_tag'
            return 'patient_action'
        elif isinstance(action, StaffAction):
            return 'staff_action'
        return 'system_auto'
    
    def _send_state_update(self, new_state: str, action_type: str):
        """WebSocketì„ í†µí•œ ìƒíƒœ ì—…ë°ì´íŠ¸ ì•Œë¦¼"""
        try:
            async_to_sync(self.channel_layer.group_send)(
                f"patient_{self.user.id}",
                {
                    "type": "state_update",
                    "journey_state": new_state,
                    "action": action_type,
                    "timestamp": timezone.now().isoformat()
                }
            )
        except Exception as e:
            # WebSocket ì „ì†¡ ì‹¤íŒ¨ëŠ” ë¬´ì‹œ (ë¡œê¹…ë§Œ)
            print(f"WebSocket notification failed: {e}")
    
    def _build_response(self, patient_state: PatientState) -> Dict[str, Any]:
        """ì‘ë‹µ ë°ì´í„° êµ¬ì„±"""
        # í™œì„± í ì¡°íšŒ
        active_queues = Queue.objects.filter(
            user=self.user,
            state__in=[QueueDetailState.WAITING.value,
                      QueueDetailState.DELAYED.value,
                      QueueDetailState.CALLED.value,
                      QueueDetailState.IN_PROGRESS.value]
        ).select_related('exam', 'appointment')
        
        # ë‹¹ì¼ ì˜ˆì•½ ì¡°íšŒ
        today = timezone.now().date()
        appointments = Appointment.objects.filter(
            user=self.user,
            scheduled_at__date=today
        ).select_related('exam')
        
        # ë‹¤ìŒ ê°€ëŠ¥í•œ ì•¡ì…˜ ê³„ì‚°
        current_state = PatientJourneyState(patient_state.current_state)
        available_actions = []
        if current_state in STATE_TRANSITIONS:
            for action in STATE_TRANSITIONS[current_state].keys():
                available_actions.append(action.value)
        
        return {
            'journey_state': patient_state.current_state,
            'queue_details': [
                {
                    'queue_id': str(q.queue_id),
                    'exam_id': q.exam.exam_id,
                    'exam_name': q.exam.title,
                    'state': q.state,
                    'queue_number': q.queue_number,
                    'estimated_wait_time': q.estimated_wait_time
                }
                for q in active_queues
            ],
            'appointments': [
                {
                    'appointment_id': a.appointment_id,
                    'exam_id': a.exam.exam_id,
                    'exam_name': a.exam.title,
                    'scheduled_at': a.scheduled_at.isoformat(),
                    'status': a.status
                }
                for a in appointments
            ],
            'available_actions': available_actions,
            'timestamp': timezone.now().isoformat()
        }
```

### 2.2 Views ë¦¬íŒ©í† ë§
```python
# p_queue/views.py (ìˆ˜ì •)
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from .services import PatientJourneyService, InvalidActionError

class PatientJourneyViewSet(viewsets.ViewSet):
    """í™˜ì ì—¬ì • ìƒíƒœ ê´€ë¦¬ API"""
    permission_classes = [IsAuthenticated]
    
    @action(detail=False, methods=['GET'])
    def current_state(self, request):
        """í˜„ì¬ í™˜ì ìƒíƒœ ì¡°íšŒ"""
        service = PatientJourneyService(request.user)
        return Response(service.get_current_state())
    
    @action(detail=False, methods=['POST'])
    def perform_action(self, request):
        """ì•¡ì…˜ ìˆ˜í–‰ì„ í†µí•œ ìƒíƒœ ì „ì´"""
        action_type = request.data.get('action_type')
        payload = request.data.get('payload', {})
        
        if not action_type:
            return Response(
                {'error': 'action_type is required'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        service = PatientJourneyService(request.user)
        try:
            result = service.perform_action(action_type, payload)
            return Response(result)
        except InvalidActionError as e:
            return Response(
                {'error': str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
```

=====================================================
## ğŸ”„ Phase 3: WebSocket ìš°ì„  ì—°ê²° ì „ëµ
=====================================================

### 3.1 WebSocket Consumer ê°œì„ 
```python
# p_queue/consumers.py (ìˆ˜ì •)
import json
from channels.generic.websocket import AsyncWebsocketConsumer
from channels.db import database_sync_to_async
from .services import PatientJourneyService

class PatientJourneyConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        self.user = self.scope["user"]
        if not self.user.is_authenticated:
            await self.close()
            return
            
        self.group_name = f"patient_{self.user.id}"
        
        # ê·¸ë£¹ì— ì°¸ì—¬
        await self.channel_layer.group_add(
            self.group_name,
            self.channel_name
        )
        
        await self.accept()
        
        # ì—°ê²° ì¦‰ì‹œ í˜„ì¬ ìƒíƒœ ì „ì†¡
        await self.send_initial_state()
    
    async def disconnect(self, close_code):
        if hasattr(self, 'group_name'):
            await self.channel_layer.group_discard(
                self.group_name,
                self.channel_name
            )
    
    async def receive(self, text_data):
        data = json.loads(text_data)
        command = data.get('command')
        
        if command == 'fetch_initial_state':
            await self.send_initial_state()
        elif command == 'perform_action':
            await self.handle_action(data)
        elif command == 'ping':
            await self.send(text_data=json.dumps({'type': 'pong'}))
    
    @database_sync_to_async
    def get_current_state(self):
        service = PatientJourneyService(self.user)
        return service.get_current_state()
    
    @database_sync_to_async
    def perform_action(self, action_type, payload):
        service = PatientJourneyService(self.user)
        return service.perform_action(action_type, payload)
    
    async def send_initial_state(self):
        """ì´ˆê¸° ìƒíƒœ ì „ì†¡"""
        state_data = await self.get_current_state()
        await self.send(text_data=json.dumps({
            'type': 'initial_state',
            'payload': state_data
        }))
    
    async def handle_action(self, data):
        """ì•¡ì…˜ ì²˜ë¦¬"""
        action_type = data.get('action_type')
        payload = data.get('payload', {})
        
        try:
            result = await self.perform_action(action_type, payload)
            await self.send(text_data=json.dumps({
                'type': 'action_result',
                'success': True,
                'payload': result
            }))
        except Exception as e:
            await self.send(text_data=json.dumps({
                'type': 'action_result',
                'success': False,
                'error': str(e)
            }))
    
    async def state_update(self, event):
        """ê·¸ë£¹ ë©”ì‹œì§€ ì²˜ë¦¬ - ìƒíƒœ ì—…ë°ì´íŠ¸ ë¸Œë¡œë“œìºìŠ¤íŠ¸"""
        await self.send(text_data=json.dumps({
            'type': 'state_update',
            'payload': {
                'journey_state': event['journey_state'],
                'action': event['action'],
                'timestamp': event['timestamp']
            }
        }))
```

### 3.2 Frontend Hook ê°œì„ 
```javascript
// hooks/usePatientJourney.js (ê°œì„ )
import { useState, useEffect, useCallback, useRef } from 'react';

export const usePatientJourney = () => {
    const [journeyState, setJourneyState] = useState(null);
    const [queueDetails, setQueueDetails] = useState(null);
    const [appointments, setAppointments] = useState([]);
    const [availableActions, setAvailableActions] = useState([]);
    const [loading, setLoading] = useState(true);
    const [isConnected, setIsConnected] = useState(false);
    const wsRef = useRef(null);
    const reconnectTimeoutRef = useRef(null);
    
    useEffect(() => {
        connectWebSocket();
        
        return () => {
            if (wsRef.current) {
                wsRef.current.close();
            }
            if (reconnectTimeoutRef.current) {
                clearTimeout(reconnectTimeoutRef.current);
            }
        };
    }, []);
    
    const connectWebSocket = () => {
        const ws = new WebSocket(`${WS_BASE_URL}/ws/patient-journey/`);
        
        ws.onopen = () => {
            console.log('WebSocket connected');
            setIsConnected(true);
            // ì—°ê²°ë˜ë©´ ì¦‰ì‹œ ì´ˆê¸° ìƒíƒœ ìš”ì²­
            ws.send(JSON.stringify({ command: 'fetch_initial_state' }));
            
            // ì—°ê²° ìœ ì§€ë¥¼ ìœ„í•œ ping
            setInterval(() => {
                if (ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ command: 'ping' }));
                }
            }, 30000); // 30ì´ˆë§ˆë‹¤
        };
        
        ws.onmessage = (event) => {
            const message = JSON.parse(event.data);
            
            switch (message.type) {
                case 'initial_state':
                case 'state_update':
                case 'action_result':
                    const { payload } = message;
                    setJourneyState(payload.journey_state);
                    setQueueDetails(payload.queue_details);
                    setAppointments(payload.appointments);
                    setAvailableActions(payload.available_actions);
                    setLoading(false);
                    break;
                    
                case 'pong':
                    // ì—°ê²° í™•ì¸
                    break;
                    
                default:
                    console.log('Unknown message type:', message.type);
            }
        };
        
        ws.onerror = (error) => {
            console.error('WebSocket error:', error);
            setIsConnected(false);
        };
        
        ws.onclose = () => {
            console.log('WebSocket disconnected');
            setIsConnected(false);
            
            // ì¬ì—°ê²° ì‹œë„
            reconnectTimeoutRef.current = setTimeout(() => {
                console.log('Attempting to reconnect...');
                connectWebSocket();
            }, 3000);
        };
        
        wsRef.current = ws;
    };
    
    const performAction = useCallback(async (actionType, payload = {}) => {
        if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) {
            // WebSocketì´ ì—°ê²°ë˜ì§€ ì•Šì€ ê²½ìš° HTTP í´ë°±
            try {
                const response = await fetch('/api/v1/patient-journey/perform-action/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${getAuthToken()}`
                    },
                    body: JSON.stringify({ action_type: actionType, payload })
                });
                
                const data = await response.json();
                if (!response.ok) {
                    throw new Error(data.error || 'Action failed');
                }
                
                // HTTP ì‘ë‹µìœ¼ë¡œ ìƒíƒœ ì—…ë°ì´íŠ¸
                setJourneyState(data.journey_state);
                setQueueDetails(data.queue_details);
                setAppointments(data.appointments);
                setAvailableActions(data.available_actions);
                
                return data;
            } catch (error) {
                console.error('Action failed:', error);
                throw error;
            }
        } else {
            // WebSocketì„ í†µí•œ ì•¡ì…˜ ìˆ˜í–‰
            wsRef.current.send(JSON.stringify({
                command: 'perform_action',
                action_type: actionType,
                payload
            }));
        }
    }, []);
    
    const refresh = useCallback(() => {
        if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
            wsRef.current.send(JSON.stringify({ command: 'fetch_initial_state' }));
        } else {
            // WebSocketì´ ì—†ìœ¼ë©´ ì¬ì—°ê²° ì‹œë„
            connectWebSocket();
        }
    }, []);
    
    return {
        // ìƒíƒœ
        journeyState,
        queueDetails,
        appointments,
        availableActions,
        loading,
        isConnected,
        
        // ì•¡ì…˜
        performAction,
        refresh
    };
};
```

=====================================================
## ğŸ”§ Phase 4: Signals ë¦¬íŒ©í† ë§
=====================================================

### 4.1 ì„œë¹„ìŠ¤ ê³„ì¸µì„ í™œìš©í•œ Signal
```python
# p_queue/signals.py (ê°œì„ )
from django.db.models.signals import post_save
from django.dispatch import receiver
from .models import Queue, PatientState
from .services import PatientJourneyService

@receiver(post_save, sender=Queue)
def sync_queue_to_patient_state(sender, instance, created, **kwargs):
    """Queue ë³€ê²½ ì‹œ PatientState ë™ê¸°í™”"""
    if created:
        return  # ìƒˆë¡œ ìƒì„±ëœ ê²½ìš°ëŠ” ì²˜ë¦¬í•˜ì§€ ì•ŠìŒ
        
    # ì„œë¹„ìŠ¤ ê³„ì¸µ ì‚¬ìš©
    service = PatientJourneyService(user=instance.user)
    service.sync_from_queue_update(instance)

@receiver(post_save, sender=PatientState)
def sync_patient_state_to_queue(sender, instance, created, **kwargs):
    """PatientState ë³€ê²½ ì‹œ Queue ë™ê¸°í™”"""
    if created:
        return
        
    # ì„œë¹„ìŠ¤ ê³„ì¸µ ì‚¬ìš©
    service = PatientJourneyService(user=instance.user)
    service.sync_from_patient_state(instance)
```

=====================================================
## ğŸ“‹ Phase 5: ë§ˆì´ê·¸ë ˆì´ì…˜ ì „ëµ
=====================================================

### 5.1 ë°ì´í„° ë§ˆì´ê·¸ë ˆì´ì…˜
```python
# p_queue/migrations/00XX_unify_state_naming.py
from django.db import migrations

def unify_state_names(apps, schema_editor):
    """ìƒíƒœëª… í†µì¼ (ongoing â†’ in_progress)"""
    Queue = apps.get_model('p_queue', 'Queue')
    PatientState = apps.get_model('p_queue', 'PatientState')
    
    # Queue ìƒíƒœëª… ë³€ê²½
    Queue.objects.filter(state='ongoing').update(state='in_progress')
    Queue.objects.filter(state='waiting').update(state='waiting')  # ê·¸ëŒ€ë¡œ
    
    # PatientState ìƒíƒœëª… ë³€ê²½
    PatientState.objects.filter(current_state='ONGOING').update(
        current_state='IN_PROGRESS'
    )
    
    # ê¸°íƒ€ ë§ˆì´ê·¸ë ˆì´ì…˜...

def reverse_unify_state_names(apps, schema_editor):
    """ë¡¤ë°±: ìƒíƒœëª… ì›ë³µ"""
    Queue = apps.get_model('p_queue', 'Queue')
    PatientState = apps.get_model('p_queue', 'PatientState')
    
    Queue.objects.filter(state='in_progress').update(state='ongoing')
    PatientState.objects.filter(current_state='IN_PROGRESS').update(
        current_state='ONGOING'
    )

class Migration(migrations.Migration):
    dependencies = [
        ('p_queue', '00XX_previous_migration'),
    ]
    
    operations = [
        migrations.RunPython(
            unify_state_names,
            reverse_unify_state_names
        ),
    ]
```

=====================================================
## ğŸ§ª Phase 6: í…ŒìŠ¤íŠ¸ ì „ëµ
=====================================================

### 6.1 ì„œë¹„ìŠ¤ ê³„ì¸µ í…ŒìŠ¤íŠ¸
```python
# tests/test_patient_journey_service.py
import pytest
from django.test import TestCase
from unittest.mock import Mock, patch
from p_queue.services import PatientJourneyService, InvalidActionError
from common.state_definitions import PatientJourneyState, PatientAction

class TestPatientJourneyService(TestCase):
    def setUp(self):
        self.user = create_test_user()
        self.service = PatientJourneyService(self.user)
    
    def test_perform_valid_action(self):
        """ìœ íš¨í•œ ì•¡ì…˜ ìˆ˜í–‰ í…ŒìŠ¤íŠ¸"""
        # UNREGISTERED ìƒíƒœì—ì„œ ì‹œì‘
        result = self.service.perform_action(
            PatientAction.SCAN_NFC.value,
            {'tag_id': 'test_tag_123'}
        )
        
        self.assertEqual(result['journey_state'], 
                        PatientJourneyState.ARRIVED.value)
        self.assertIn(PatientAction.REGISTER.value, 
                     result['available_actions'])
    
    def test_invalid_action_raises_error(self):
        """ì˜ëª»ëœ ì•¡ì…˜ ì‹œ ì—ëŸ¬ ë°œìƒ í…ŒìŠ¤íŠ¸"""
        with self.assertRaises(InvalidActionError):
            # UNREGISTERED ìƒíƒœì—ì„œ CALL_PATIENTëŠ” ë¶ˆê°€ëŠ¥
            self.service.perform_action('call_patient')
    
    def test_queue_sync_updates_patient_state(self):
        """Queue ë™ê¸°í™” í…ŒìŠ¤íŠ¸"""
        # PatientStateë¥¼ WAITINGìœ¼ë¡œ ì„¤ì •
        patient_state = PatientState.objects.create(
            user=self.user,
            current_state=PatientJourneyState.WAITING.value
        )
        
        # Queue ìƒì„± ë° ìƒíƒœ ë³€ê²½
        queue = Queue.objects.create(
            user=self.user,
            state='waiting',
            exam_id='test_exam'
        )
        
        queue.state = 'called'
        queue.save()
        
        # Signalì„ í†µí•´ ì„œë¹„ìŠ¤ê°€ í˜¸ì¶œë˜ê³  ìƒíƒœê°€ ë™ê¸°í™”ë˜ì–´ì•¼ í•¨
        patient_state.refresh_from_db()
        self.assertEqual(patient_state.current_state,
                        PatientJourneyState.CALLED.value)
    
    @patch('p_queue.services.async_to_sync')
    def test_websocket_notification_sent(self, mock_async):
        """WebSocket ì•Œë¦¼ ì „ì†¡ í…ŒìŠ¤íŠ¸"""
        # ì•¡ì…˜ ìˆ˜í–‰
        self.service.perform_action(PatientAction.SCAN_NFC.value)
        
        # WebSocket ì•Œë¦¼ì´ í˜¸ì¶œë˜ì—ˆëŠ”ì§€ í™•ì¸
        mock_async.assert_called()
```

### 6.2 í†µí•© í…ŒìŠ¤íŠ¸
```python
# tests/test_integration.py
from channels.testing import WebsocketCommunicator
from django.test import TransactionTestCase
from p_queue.consumers import PatientJourneyConsumer

class TestWebSocketIntegration(TransactionTestCase):
    async def test_websocket_receives_initial_state(self):
        """WebSocket ì—°ê²° ì‹œ ì´ˆê¸° ìƒíƒœ ìˆ˜ì‹  í…ŒìŠ¤íŠ¸"""
        communicator = WebsocketCommunicator(
            PatientJourneyConsumer.as_asgi(),
            "/ws/patient-journey/"
        )
        
        # ì—°ê²°
        connected, _ = await communicator.connect()
        self.assertTrue(connected)
        
        # ì´ˆê¸° ìƒíƒœ ë©”ì‹œì§€ ìˆ˜ì‹ 
        message = await communicator.receive_json_from()
        self.assertEqual(message['type'], 'initial_state')
        self.assertIn('journey_state', message['payload'])
        
        await communicator.disconnect()
    
    async def test_action_through_websocket(self):
        """WebSocketì„ í†µí•œ ì•¡ì…˜ ìˆ˜í–‰ í…ŒìŠ¤íŠ¸"""
        communicator = WebsocketCommunicator(
            PatientJourneyConsumer.as_asgi(),
            "/ws/patient-journey/"
        )
        
        connected, _ = await communicator.connect()
        
        # ì•¡ì…˜ ì „ì†¡
        await communicator.send_json_to({
            'command': 'perform_action',
            'action_type': 'scan_nfc',
            'payload': {'tag_id': 'test_123'}
        })
        
        # ê²°ê³¼ ìˆ˜ì‹ 
        message = await communicator.receive_json_from()
        self.assertEqual(message['type'], 'action_result')
        self.assertTrue(message['success'])
        
        await communicator.disconnect()
```

=====================================================
## ğŸ“Š ëª¨ë‹ˆí„°ë§ ë° ë””ë²„ê¹…
=====================================================

### 7.1 ìƒíƒœ ì¼ê´€ì„± ì²´í¬
```python
# management/commands/check_state_health.py
from django.core.management.base import BaseCommand
from django.db import connection
from p_queue.models import Queue, PatientState
from common.state_definitions import QUEUE_TO_JOURNEY_MAPPING

class Command(BaseCommand):
    help = 'ìƒíƒœ ì¼ê´€ì„± ë° ì‹œìŠ¤í…œ í—¬ìŠ¤ ì²´í¬'
    
    def handle(self, *args, **options):
        self.check_state_consistency()
        self.check_orphaned_states()
        self.check_transition_logs()
        self.print_statistics()
    
    def check_state_consistency(self):
        """Queueì™€ PatientState ê°„ ì¼ê´€ì„± ì²´í¬"""
        inconsistencies = []
        
        for patient_state in PatientState.objects.all():
            active_queue = Queue.objects.filter(
                user=patient_state.user,
                state__in=['waiting', 'called', 'in_progress']
            ).first()
            
            if active_queue:
                expected = QUEUE_TO_JOURNEY_MAPPING.get(
                    QueueDetailState(active_queue.state)
                )
                if expected and patient_state.current_state != expected.value:
                    inconsistencies.append({
                        'user': patient_state.user.id,
                        'patient_state': patient_state.current_state,
                        'queue_state': active_queue.state,
                        'expected': expected.value
                    })
        
        if inconsistencies:
            self.stdout.write(
                self.style.ERROR(f'Found {len(inconsistencies)} inconsistencies:')
            )
            for item in inconsistencies[:10]:  # ì²˜ìŒ 10ê°œë§Œ í‘œì‹œ
                self.stdout.write(f"  User {item['user']}: "
                                f"PS={item['patient_state']}, "
                                f"Q={item['queue_state']}, "
                                f"Expected={item['expected']}")
        else:
            self.stdout.write(
                self.style.SUCCESS('âœ“ All states are consistent')
            )
        
        return len(inconsistencies)
    
    def check_orphaned_states(self):
        """ê³ ì•„ ìƒíƒœ ì²´í¬ (Queue ì—†ëŠ” WAITING/CALLED ìƒíƒœ)"""
        orphaned = PatientState.objects.filter(
            current_state__in=['WAITING', 'CALLED', 'IN_PROGRESS']
        ).exclude(
            user__in=Queue.objects.filter(
                state__in=['waiting', 'called', 'in_progress']
            ).values_list('user', flat=True)
        )
        
        if orphaned.exists():
            self.stdout.write(
                self.style.WARNING(f'Found {orphaned.count()} orphaned states')
            )
        else:
            self.stdout.write(
                self.style.SUCCESS('âœ“ No orphaned states')
            )
    
    def check_transition_logs(self):
        """ìƒíƒœ ì „í™˜ ë¡œê·¸ ë¬´ê²°ì„± ì²´í¬"""
        with connection.cursor() as cursor:
            cursor.execute("""
                SELECT COUNT(*)
                FROM state_transitions
                WHERE to_state NOT IN (
                    'UNREGISTERED', 'ARRIVED', 'REGISTERED',
                    'WAITING', 'CALLED', 'IN_PROGRESS',
                    'COMPLETED', 'PAYMENT', 'FINISHED'
                )
            """)
            invalid_count = cursor.fetchone()[0]
            
        if invalid_count > 0:
            self.stdout.write(
                self.style.ERROR(f'Found {invalid_count} invalid transitions')
            )
        else:
            self.stdout.write(
                self.style.SUCCESS('âœ“ All transitions are valid')
            )
    
    def print_statistics(self):
        """ì‹œìŠ¤í…œ í†µê³„ ì¶œë ¥"""
        stats = {
            'total_patients': PatientState.objects.count(),
            'active_queues': Queue.objects.filter(
                state__in=['waiting', 'called', 'in_progress']
            ).count(),
            'state_distribution': {}
        }
        
        # ìƒíƒœë³„ ë¶„í¬
        for state in PatientJourneyState:
            count = PatientState.objects.filter(
                current_state=state.value
            ).count()
            stats['state_distribution'][state.value] = count
        
        self.stdout.write(self.style.SUCCESS('\n=== System Statistics ==='))
        self.stdout.write(f"Total Patients: {stats['total_patients']}")
        self.stdout.write(f"Active Queues: {stats['active_queues']}")
        self.stdout.write('\nState Distribution:')
        for state, count in stats['state_distribution'].items():
            self.stdout.write(f"  {state}: {count}")
```

=====================================================
## ğŸš€ êµ¬í˜„ ë¡œë“œë§µ
=====================================================

### Week 1: ê¸°ë°˜ êµ¬ì¶•
- [ ] Backend ìƒíƒœ ì •ì˜ íŒŒì¼ ìƒì„± (state_definitions.py)
- [ ] PatientJourneyService í´ë˜ìŠ¤ êµ¬í˜„
- [ ] ìƒíƒœ ì •ì˜ API ì—”ë“œí¬ì¸íŠ¸ ì¶”ê°€
- [ ] ê¸°ë³¸ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ì‘ì„±

### Week 2: API ë° ì„œë¹„ìŠ¤ ê³„ì¸µ
- [ ] PatientJourneyViewSet êµ¬í˜„ (ì•¡ì…˜ ê¸°ë°˜)
- [ ] WebSocket Consumer ê°œì„ 
- [ ] Signals ë¦¬íŒ©í† ë§ (ì„œë¹„ìŠ¤ ê³„ì¸µ í™œìš©)
- [ ] ì„œë¹„ìŠ¤ ê³„ì¸µ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸

### Week 3: Frontend í†µí•©
- [ ] usePatientJourney Hook êµ¬í˜„
- [ ] WebSocket ìš°ì„  ì—°ê²° ë¡œì§
- [ ] ìƒíƒœ ì •ì˜ ë™ì  ë¡œë“œ
- [ ] ê¸°ì¡´ ì»´í¬ë„ŒíŠ¸ ì ì§„ì  ë§ˆì´ê·¸ë ˆì´ì…˜

### Week 4: ë°ì´í„° ë§ˆì´ê·¸ë ˆì´ì…˜
- [ ] ìƒíƒœëª… í†µì¼ ë§ˆì´ê·¸ë ˆì´ì…˜ (ongoing â†’ in_progress)
- [ ] ê¸°ì¡´ ë°ì´í„° ì •í•©ì„± ê²€ì¦
- [ ] ë¡¤ë°± ê³„íš ìˆ˜ë¦½ ë° í…ŒìŠ¤íŠ¸
- [ ] ìŠ¤í…Œì´ì§• í™˜ê²½ ë°°í¬

### Week 5: í…ŒìŠ¤íŠ¸ ë° ëª¨ë‹ˆí„°ë§
- [ ] í†µí•© í…ŒìŠ¤íŠ¸ suite êµ¬ì¶•
- [ ] ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ (WebSocket vs HTTP)
- [ ] ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ êµ¬ì¶•
- [ ] ìƒíƒœ ì¼ê´€ì„± ì²´í¬ ìë™í™”

### Week 6: ë°°í¬ ë° ìµœì í™”
- [ ] í”„ë¡œë•ì…˜ ë°°í¬ (Blue-Green)
- [ ] ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§
- [ ] ì„±ëŠ¥ íŠœë‹
- [ ] ë¬¸ì„œí™” ì™„ë£Œ

=====================================================
## ğŸ“ˆ ì„±ê³µ ì§€í‘œ (ê°œì„ )
=====================================================

### ì •ëŸ‰ì  ì§€í‘œ
1. **ìƒíƒœ ë¶ˆì¼ì¹˜ìœ¨**: < 0.01% (ê¸°ì¡´ 0.1%)
2. **API ì‘ë‹µ ì‹œê°„**: < 100ms (ê¸°ì¡´ 200ms)
3. **WebSocket ì—°ê²° ì•ˆì •ì„±**: > 99.9% (ê¸°ì¡´ 99%)
4. **ì½”ë“œ ì¤‘ë³µ ì œê±°ìœ¨**: > 90% (ê¸°ì¡´ 80%)
5. **í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€**: > 95% (ê¸°ì¡´ 90%)
6. **ì•¡ì…˜ ì²˜ë¦¬ ì‹¤íŒ¨ìœ¨**: < 0.5%

### ì •ì„±ì  ì§€í‘œ
1. **ê°œë°œì ê²½í—˜**: ìƒíƒœ ê´€ë¦¬ ë³µì¡ë„ 50% ê°ì†Œ
2. **ìœ ì§€ë³´ìˆ˜ì„±**: ìƒˆë¡œìš´ ìƒíƒœ/ì•¡ì…˜ ì¶”ê°€ ì‹œê°„ 70% ë‹¨ì¶•
3. **ë””ë²„ê¹… íš¨ìœ¨**: ìƒíƒœ ë¬¸ì œ í•´ê²° ì‹œê°„ 60% ë‹¨ì¶•
4. **ì‹œìŠ¤í…œ ì‹ ë¢°ì„±**: ìƒíƒœ ê´€ë ¨ ë²„ê·¸ 80% ê°ì†Œ

=====================================================
## ğŸ”’ ë¦¬ìŠ¤í¬ ê´€ë¦¬ (ê°•í™”)
=====================================================

### ë¦¬ìŠ¤í¬ ë§¤íŠ¸ë¦­ìŠ¤
| ë¦¬ìŠ¤í¬ | í™•ë¥  | ì˜í–¥ë„ | ëŒ€ì‘ ì „ëµ |
|--------|------|--------|----------|
| WebSocket ì—°ê²° ì‹¤íŒ¨ | ì¤‘ | ë†’ìŒ | HTTP í´ë°± ë©”ì»¤ë‹ˆì¦˜ |
| ìƒíƒœ ì „ì´ ì¶©ëŒ | ë‚®ìŒ | ë†’ìŒ | íŠ¸ëœì­ì…˜ + ë‚™ê´€ì  ì ê¸ˆ |
| ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤íŒ¨ | ë‚®ìŒ | ë§¤ìš° ë†’ìŒ | ë‹¨ê³„ë³„ ë¡¤ë°± ê³„íš |
| ì„±ëŠ¥ ì €í•˜ | ì¤‘ | ì¤‘ê°„ | ìºì‹± + ì¸ë±ìŠ¤ ìµœì í™” |
| ì„œë“œíŒŒí‹° ì˜ì¡´ì„± | ë‚®ìŒ | ë‚®ìŒ | ìµœì†Œ ì˜ì¡´ì„± ìœ ì§€ |

### ë¡¤ë°± ê³„íš
1. **Phaseë³„ ë…ë¦½ ë°°í¬**: ê° PhaseëŠ” ë…ë¦½ì ìœ¼ë¡œ ë¡¤ë°± ê°€ëŠ¥
2. **Feature Flag ì‚¬ìš©**: ì‹ ê·œ ê¸°ëŠ¥ì„ í”Œë˜ê·¸ë¡œ ì œì–´
3. **ë°ì´í„°ë² ì´ìŠ¤ ë°±ì—…**: ë§ˆì´ê·¸ë ˆì´ì…˜ ì „ ìë™ ë°±ì—…
4. **Blue-Green ë°°í¬**: ë¬´ì¤‘ë‹¨ ë¡¤ë°± ì§€ì›

=====================================================
## ğŸ“š ì°¸ê³  ìë£Œ
=====================================================

- Django Channels ê³µì‹ ë¬¸ì„œ
- WebSocket í”„ë¡œí† ì½œ RFC 6455
- Event-Driven Architecture íŒ¨í„´
- Domain-Driven Design (DDD) ì›ì¹™
- SOLID ì„¤ê³„ ì›ì¹™

---
END OF IMPROVED PLAN v2